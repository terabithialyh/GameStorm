<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INFINITE FALL: CHOKE ON ADRENALINE</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Black Ops One', sans-serif;
            /* Fallback font */
            touch-action: none;
            overscroll-behavior: none;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
            mix-blend-mode: difference;
        }

        #score {
            font-size: 40px;
            font-weight: bold;
        }

        #best {
            font-size: 16px;
            color: #bbb;
            margin-top: 2px;
        }

        #combo {
            font-size: 18px;
            color: #aef;
            margin-top: 4px;
        }

        #speed-bar {
            width: 200px;
            height: 20px;
            border: 2px solid white;
            margin-top: 10px;
            position: relative;
        }

        #speed-fill {
            height: 100%;
            background: yellow;
            width: 0%;
        }

        #stability-bar {
            width: 200px;
            height: 14px;
            border: 2px solid white;
            margin-top: 8px;
            position: relative;
        }

        #stability-fill {
            height: 100%;
            background: lime;
            width: 100%;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: cyan;
            z-index: 10;
        }

        h1 {
            font-size: 5rem;
            text-shadow: 4px 4px magenta;
            margin: 0;
            text-transform: uppercase;
            text-align: center;
        }

        p {
            font-size: 1.5rem;
            color: white;
        }

        button {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 1.2rem;
            background: cyan;
            color: #000;
            border: none;
            cursor: pointer;
        }

        #pause-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 5;
            pointer-events: auto;
            padding: 10px 18px;
            font-size: 1rem;
            background: #00f0ff;
            color: #000;
            border: none;
            cursor: pointer;
            display: none;
        }

        #pause-screen .details {
            margin-top: 10px;
            font-size: 1.1rem;
            color: #fff;
            max-width: 600px;
            text-align: left;
            line-height: 1.6;
        }

        #pause-screen .details p {
            font-size: 1.1rem;
            margin: 6px 0;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div id="score">DEPTH: 0m</div>
        <div id="best">BEST: 0m</div>
        <div id="combo">连躲: 0</div>
        <div id="speed-bar">
            <div id="speed-fill"></div>
        </div>
        <div id="stability-bar">
            <div id="stability-fill"></div>
        </div>
        <div id="mode-text" style="font-size: 20px; color: magenta; display: none;">FLOW x2</div>
    </div>

    <button id="pause-btn">暂停</button>

    <div id="start-screen" class="screen">
        <h1>Infinite Fall</h1>
        <p>左右滑动屏幕（或方向键）换线</p>
        <p>下落中躲避圆环</p>
        <p>撞到圆环两次即失败</p>
        <p>节奏会逐渐加速并随音乐起伏</p>
        <p>点击开始</p>
    </div>

    <div id="pause-screen" class="screen hidden">
        <h1>暂停</h1>
        <p>按 空格 / P / ESC 或点击屏幕继续</p>
        <div class="details">
            <p>玩法说明：</p>
            <p>1. 左右滑动屏幕或按方向键切换车道。</p>
            <p>2. 圆环到达角色高度就是节拍点，避开同车道圆环。</p>
            <p>3. 撞到圆环两次即失败。</p>
            <p>4. 躲避 20 次后，连躲会变成“递减”而不是清零。</p>
            <p>5. 节奏会逐渐加速并随音乐波动，抓住节拍更容易连躲。</p>
        </div>
    </div>

    <div id="end-screen" class="screen hidden">
        <h1>坠毁</h1>
        <p id="final-score">DEPTH: 0m</p>
        <p id="final-best">BEST: 0m</p>
        <button id="restart-btn">重新开始</button>
    </div>

    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // State
        let width, height;
        let playing = false;
        let paused = false;
        let gameOver = false;
        let score = 0;
        let bestScore = 0;
        let speed = 0;
        const START_SPEED = 520;
        const BASE_SPEED = 820;
        const MAX_SPEED = 1800;
        const MAX_STABILITY = 100;
        const MAX_HITS = 2;
        const LANE_COUNT = 3;
        const DODGE_UNLOCK = 20;
        const START_BPM = 90;
        const BASE_BPM = 120;
        const START_SWING = 8;
        const BPM_SWING = 35;
        const BPM_WAVE_SPEED = 0.45;
        const LOOKAHEAD = 1.1;
        const RAMP_TIME = 20;
        let player = { x: 0, y: 0, w: 40, h: 40, vx: 0, vy: 0 };
        let cameraY = 0;
        let rings = [];
        let particles = [];
        let combo = 0;
        let totalDodges = 0;
        let shakeStrength = 0;
        let time = 0;
        let stability = MAX_STABILITY;
        let hitCount = 0;
        let bpm = BASE_BPM;
        let beatInterval = 60 / BASE_BPM;
        let beatTimer = 0;
        let musicPhase = 0;
        let difficultyTime = 0;
        let difficultyRamp = 0;
        let tempoBase = BASE_BPM;
        let tempoSwing = BPM_SWING;
        let lanes = [];
        let laneIndex = 1;
        let targetX = 0;
        let lastLane = -1;
        let beatPulse = 0;
        let beatCount = 0;
        let lastTime = 0;
        let beatLane = -1;
        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeActive = false;

        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const comboEl = document.getElementById('combo');
        const speedFill = document.getElementById('speed-fill');
        const stabilityFill = document.getElementById('stability-fill');
        const modeText = document.getElementById('mode-text');
        const startScreen = document.getElementById('start-screen');
        const endScreen = document.getElementById('end-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const finalScore = document.getElementById('final-score');
        const finalBest = document.getElementById('final-best');
        const restartBtn = document.getElementById('restart-btn');
        const pauseBtn = document.getElementById('pause-btn');

        // Audio
        let audioCtx;
        let engineOsc, engineGain;
        let filterNode;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            lanes = [];
            for (let i = 0; i < LANE_COUNT; i++) {
                lanes.push(((i + 1) / (LANE_COUNT + 1)) * width);
            }
            targetX = lanes[laneIndex] || width / 2;
            if (!playing) {
                player.x = targetX;
                player.y = height / 3;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        bestScore = Number(localStorage.getItem('trustme_best') || 0);
        bestEl.innerText = `BEST: ${bestScore}m`;

        // Input
        function changeLane(dir) {
            if (!playing || paused || gameOver) return;
            const next = Math.max(0, Math.min(LANE_COUNT - 1, laneIndex + dir));
            if (next === laneIndex) return;
            laneIndex = next;
            targetX = lanes[laneIndex] || targetX;
            shakeStrength = Math.max(shakeStrength, 4);
        }

        window.addEventListener('keydown', e => {
            const key = e.key;
            if (key === 'ArrowLeft') {
                changeLane(-1);
                e.preventDefault();
            }
            if (key === 'ArrowRight') {
                changeLane(1);
                e.preventDefault();
            }
            if (key === ' ' || e.code === 'Space') {
                if (!playing) initGame();
                else togglePause();
                e.preventDefault();
            }
            if (!playing && key === 'Enter') {
                initGame();
                e.preventDefault();
            }
            if (playing && (key.toLowerCase() === 'p' || key === 'Escape')) {
                togglePause();
                e.preventDefault();
            }
        });

        // Swipe on touch, click on mouse
        window.addEventListener('pointerdown', e => {
            if (!playing || paused || gameOver) return;
            if (e.pointerType === 'mouse') {
                if (e.clientX < width / 2) changeLane(-1);
                else changeLane(1);
                return;
            }
            swipeActive = true;
            swipeStartX = e.clientX;
            swipeStartY = e.clientY;
            e.preventDefault();
        });

        window.addEventListener('pointerup', e => {
            if (!swipeActive) return;
            swipeActive = false;
            const dx = e.clientX - swipeStartX;
            const dy = e.clientY - swipeStartY;
            const absX = Math.abs(dx);
            const absY = Math.abs(dy);
            const threshold = Math.max(30, width * 0.08);
            if (absX > threshold && absX > absY * 1.2) {
                changeLane(dx < 0 ? -1 : 1);
            }
            e.preventDefault();
        });

        window.addEventListener('pointercancel', () => {
            swipeActive = false;
        });

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Engine Drone
            engineOsc = audioCtx.createOscillator();
            engineGain = audioCtx.createGain();
            filterNode = audioCtx.createBiquadFilter();

            engineOsc.type = 'sawtooth';
            engineOsc.frequency.value = 50;

            filterNode.type = 'lowpass';
            filterNode.frequency.value = 200;

            engineOsc.connect(filterNode);
            filterNode.connect(engineGain);
            engineGain.connect(audioCtx.destination);

            engineGain.gain.value = 0;
            engineOsc.start();
        }

        function setEngineVolume(value) {
            if (!audioCtx || !engineGain) return;
            engineGain.gain.setTargetAtTime(value, audioCtx.currentTime, 0.1);
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'coin') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800 + (combo * 100), now);
                osc.frequency.exponentialRampToValueAtTime(1200 + (combo * 100), now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(220, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                osc.start(now);
                osc.stop(now + 0.25);
            } else if (type === 'mode') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(800, now + 1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 1);
                osc.start(now);
                osc.stop(now + 1);
            } else if (type === 'beat') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(60, now + 0.12);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                osc.start(now);
                osc.stop(now + 0.12);
            } else if (type === 'beat-strong') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(90, now + 0.18);
                gain.gain.setValueAtTime(0.55, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                osc.start(now);
                osc.stop(now + 0.18);
            }
        }

        function spawnRing(y) {
            let lane = Math.floor(Math.random() * LANE_COUNT);
            if (lane === lastLane) {
                lane = (lane + 1 + Math.floor(Math.random() * (LANE_COUNT - 1))) % LANE_COUNT;
            }
            lastLane = lane;
            const laneSpacing = width / (LANE_COUNT + 1);
            const ringWidth = Math.min(220, Math.max(110, laneSpacing * 0.8));
            const ringHeight = Math.max(20, ringWidth * 0.18);
            const x = lanes[lane] || width / 2;
            rings.push({
                y: y,
                x: x,
                w: ringWidth,
                h: ringHeight,
                lane: lane,
                beatPlayed: false,
                cleared: false,
                active: true,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`
            });
        }

        function initGame() {
            if (!audioCtx) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            setEngineVolume(0.2);

            playing = true;
            paused = false;
            gameOver = false;
            pauseBtn.style.display = 'block';
            score = 0;
            speed = START_SPEED;
            bpm = START_BPM;
            beatInterval = 60 / bpm;
            beatTimer = 0;
            musicPhase = 0;
            difficultyTime = 0;
            difficultyRamp = 0;
            tempoBase = START_BPM;
            tempoSwing = START_SWING;
            laneIndex = Math.floor(LANE_COUNT / 2);
            targetX = lanes[laneIndex] || width / 2;
            player.x = targetX;
            player.y = height / 3; // Player stays fixed in Y, world moves up
            cameraY = 0;
            rings = [];
            particles = [];
            combo = 0;
            totalDodges = 0;
            shakeStrength = 0;
            stability = MAX_STABILITY;
            hitCount = 0;
            lastLane = -1;
            beatPulse = 0;
            beatCount = 0;
            time = 0;
            lastTime = performance.now();
            beatLane = -1;

            modeText.style.display = 'none';
            pauseScreen.classList.add('hidden');
            endScreen.classList.add('hidden');

            for (let i = 0; i < 6; i++) {
                const spawnY = cameraY + player.y + speed * (LOOKAHEAD + beatInterval * i);
                spawnRing(spawnY);
            }

            startScreen.classList.add('hidden');
            requestAnimationFrame(loop);
        }

        function createExplosion(x, y, color) {
            const count = Math.max(16, 28 - Math.min(combo, 10));
            if (particles.length > 500) return;
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 1.0,
                    color: color,
                    r: Math.random() * 4 + 3
                });
            }
        }

        function endGame() {
            playing = false;
            gameOver = true;
            setEngineVolume(0.0);
            pauseBtn.style.display = 'none';

            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('trustme_best', bestScore);
            }
            bestEl.innerText = `BEST: ${bestScore}m`;
            finalScore.innerText = `DEPTH: ${score}m`;
            finalBest.innerText = `BEST: ${bestScore}m`;
            endScreen.classList.remove('hidden');
        }

        function togglePause() {
            if (!playing || gameOver) return;
            paused = !paused;
            pauseScreen.classList.toggle('hidden', !paused);
            setEngineVolume(paused ? 0.05 : 0.2);
        }

        function updateTempo(dt) {
            difficultyTime += dt;
            difficultyRamp = Math.min(1, difficultyTime / RAMP_TIME);
            musicPhase += dt * BPM_WAVE_SPEED * Math.PI * 2;
            const wave = Math.sin(musicPhase);
            const wave2 = Math.sin(musicPhase * 0.35 + 1.2);
            tempoBase = START_BPM + (BASE_BPM - START_BPM) * difficultyRamp;
            tempoSwing = START_SWING + (BPM_SWING - START_SWING) * difficultyRamp;
            bpm = tempoBase + wave * tempoSwing + wave2 * (tempoSwing * 0.45);
            bpm = Math.max(80, Math.min(170, bpm));
            beatInterval = 60 / bpm;
        }

        function update(dt) {
            updateTempo(dt);

            // Difficulty scaling
            const baseSpeed = START_SPEED + (BASE_SPEED - START_SPEED) * difficultyRamp;
            speed = Math.min(MAX_SPEED, baseSpeed + (bpm - tempoBase) * 6 + combo * 14);

            // Snap movement between lanes for rhythm feel
            const diff = targetX - player.x;
            const snap = 1 - Math.pow(1 - 0.35, dt * 60);
            player.vx = diff * snap * 10;
            player.x += diff * snap;

            // Camera/World Movement
            cameraY += speed * dt;
            score = Math.floor(cameraY / 100);
            if (score > bestScore) bestScore = score;

            // UI update
            scoreEl.innerText = `DEPTH: ${score}m`;
            bestEl.innerText = `BEST: ${bestScore}m`;
            comboEl.innerText = `连躲: ${combo}`;
            speedFill.style.width = Math.min(100, (speed / MAX_SPEED) * 100) + '%';

            const stabilityPercent = Math.max(0, stability) / MAX_STABILITY;
            stabilityFill.style.width = (stabilityPercent * 100) + '%';
            const stabilityHue = stabilityPercent * 120;
            stabilityFill.style.background = `hsl(${stabilityHue}, 90%, 50%)`;

            if (combo >= 5) {
                modeText.style.display = 'block';
                modeText.innerText = combo === 5 ? "FLOW!" : "FLOW x" + Math.min(5, combo - 3);
            } else {
                modeText.style.display = 'none';
            }

            // Beat-driven spawns
            beatTimer += dt;
            let guard = 0;
            while (beatTimer >= beatInterval && guard < 5) {
                beatTimer -= beatInterval;
                const spawnY = cameraY + player.y + speed * LOOKAHEAD;
                spawnRing(spawnY);
                guard++;
            }

            // Rings Logic
            for (let i = rings.length - 1; i >= 0; i--) {
                const r = rings[i];
                const ringScreenY = r.y - cameraY;

                // If ring passes player
                if (ringScreenY < player.y + r.h && ringScreenY > player.y - r.h && r.active) {
                    const xDiff = Math.abs(player.x - r.x);
                    if (r.lane === laneIndex && xDiff < r.w * 0.45) {
                        // Hit (bad)
                        r.active = false;
                        if (totalDodges >= DODGE_UNLOCK) combo = Math.max(0, combo - 5);
                        else combo = 0;
                        hitCount++;
                        stability = Math.max(0, MAX_STABILITY * (1 - hitCount / MAX_HITS));
                        shakeStrength = Math.min(28, 12 + combo * 2);
                        createExplosion(player.x, player.y, '#ff3355');
                        playSound('hit');
                    } else if (!r.cleared && r.lane !== laneIndex) {
                        // Dodge (good)
                        r.cleared = true;
                        combo++;
                        totalDodges++;
                        shakeStrength = Math.min(22, 6 + combo);
                        playSound('coin');
                        if (combo === 5) playSound('mode');
                    }
                }

                // Beat cue when ring reaches player line
                if (!r.beatPlayed && ringScreenY <= player.y) {
                    r.beatPlayed = true;
                    beatCount++;
                    beatPulse = 1;
                    beatLane = r.lane;
                    playSound(beatCount % 4 === 0 ? 'beat-strong' : 'beat');
                }

                // Clean up and spawn new
                if (ringScreenY < -120) {
                    rings.splice(i, 1);
                }
            }

            // Particles
            const frame = dt * 60;
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * frame;
                p.y += p.vy * frame;
                p.vy += 0.3 * frame;
                p.life -= 0.04 * frame;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Screen Shake decay
            if (shakeStrength > 0) shakeStrength *= Math.pow(0.9, frame);

            // Audio update
            if (audioCtx) {
                engineOsc.frequency.setTargetAtTime(50 + speed * 2, audioCtx.currentTime, 0.1);
                filterNode.frequency.setTargetAtTime(200 + speed * 50, audioCtx.currentTime, 0.1);
            }

            if (hitCount >= MAX_HITS) endGame();

            if (beatPulse > 0) beatPulse *= Math.pow(0.82, frame);
        }

        function drawPlayerShape(x, y, w, h, r) {
            const radius = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(x, y, w, h, radius);
                return;
            }
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.arcTo(x + w, y, x + w, y + radius, radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
            ctx.lineTo(x + radius, y + h);
            ctx.arcTo(x, y + h, x, y + h - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        function draw() {
            // Screen Shake transform
            let shakeX = (Math.random() - 0.5) * shakeStrength;
            let shakeY = (Math.random() - 0.5) * shakeStrength;

            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Background / Tunnel effect
            // Dynamic background color based on speed
            let hue = (time * 0.1) % 360;
            if (combo >= 5) {
                // Uncontrollable / Warp mode visuals
                ctx.fillStyle = `rgba(${Math.random() * 255}, 0, ${Math.random() * 255}, 0.5)`; // Flash
            } else {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#0b0b14');
                gradient.addColorStop(1, '#050508');
                ctx.fillStyle = gradient;
            }
            ctx.fillRect(-20, -20, width + 40, height + 40);

            // Draw grid lines to show speed
            ctx.strokeStyle = `hsla(${hue}, 50%, 50%, 0.3)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            let gridOffset = cameraY % 200;
            for (let i = 0; i < height + 200; i += 200) {
                let y = i - gridOffset;
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            // Vertical lines
            for (let i = 0; i < width; i += 200) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
            }
            ctx.stroke();

            // Lane guides
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.16)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < lanes.length; i++) {
                ctx.moveTo(lanes[i], 0);
                ctx.lineTo(lanes[i], height);
            }
            ctx.stroke();
            if (lanes[laneIndex] !== undefined) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.55)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(lanes[laneIndex], 0);
                ctx.lineTo(lanes[laneIndex], height);
                ctx.stroke();
            }

            // Beat lane flash
            if (beatPulse > 0.01 && beatLane >= 0 && lanes[beatLane] !== undefined) {
                const leftBound = beatLane === 0 ? 0 : (lanes[beatLane - 1] + lanes[beatLane]) / 2;
                const rightBound = beatLane === lanes.length - 1 ? width : (lanes[beatLane] + lanes[beatLane + 1]) / 2;
                ctx.fillStyle = `rgba(0, 255, 255, ${beatPulse * 0.28})`;
                ctx.fillRect(leftBound, 0, rightBound - leftBound, height);
                ctx.strokeStyle = `rgba(0, 255, 255, ${beatPulse * 0.85})`;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(lanes[beatLane], 0);
                ctx.lineTo(lanes[beatLane], height);
                ctx.stroke();
            }

            // Rings
            ctx.lineWidth = 10;
            for (let r of rings) {
                let ry = r.y - cameraY;
                if (ry > -50 && ry < height + 50) {
                    // Perspective squash for 3D feel
                    // As it gets closer to center? No, just flat ovals
                    ctx.strokeStyle = r.active ? r.color : '#333';
                    ctx.beginPath();
                    ctx.ellipse(r.x, ry, r.w / 2, r.h / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    // Glow
                    if (r.active) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = r.color;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Player (Soft Body)
            // Squash X based on Speed, Squash Y? 
            // falling implies stretching Y.
            // Impact implies squashing Y.
            let stretch = 1 + (speed / 1200);
            let playerDrawW = player.w / stretch;
            let playerDrawH = player.h * stretch;

            // Lean
            let angle = player.vx * 0.1;

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(angle);

            ctx.fillStyle = combo >= 5 ? '#fff' : 'cyan';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;

            // Draw Jelly character
            // A simple rounded rect or blob
            drawPlayerShape(-playerDrawW / 2, -playerDrawH / 2, playerDrawW, playerDrawH, 20);
            ctx.fill();
            ctx.stroke();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-5, -5, 5, 0, Math.PI * 2);
            ctx.arc(5, -5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-5 + player.vx, -5, 2, 0, Math.PI * 2);
            ctx.arc(5 + player.vx, -5, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Particles
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            if (hitCount >= 1) {
                const pulse = (Math.sin(time * 0.2) + 1) / 2;
                ctx.fillStyle = `rgba(255, 0, 0, ${0.08 + pulse * 0.12})`;
                ctx.fillRect(0, 0, width, height);
            }

            if (beatPulse > 0.01) {
                ctx.fillStyle = `rgba(255, 255, 255, ${beatPulse * 0.28})`;
                ctx.fillRect(0, 0, width, height);
            }

            ctx.restore();
        }

        function loop() {
            if (!playing) return;
            const now = performance.now();
            const dt = Math.min(0.05, Math.max(0.001, (now - lastTime) / 1000));
            lastTime = now;
            if (paused) {
                draw();
                requestAnimationFrame(loop);
                return;
            }
            time += dt * 60;
            update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        startScreen.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        pauseScreen.addEventListener('click', togglePause);
        pauseBtn.addEventListener('click', togglePause);

    </script>
</body>

</html>
