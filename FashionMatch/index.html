<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fashion Match - Êó∂Â∞öÊ∂àÊ∂à‰πê</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Ê∏∏ÊàèÂÆπÂô®ÔºåÁª¥ÊåÅ 9:16 ÊØî‰æã */
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 56.25vh; /* 9/16 = 0.5625 */
            background: linear-gradient(180deg, #FF9A9E 0%, #FECFEF 99%, #FECFEF 100%);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Â±Ç */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            padding: 20px;
            text-align: center;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .score-box {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            padding: 10px 30px;
            display: inline-block;
            margin-top: 10px;
            border: 3px solid #ff758c;
        }

        h1 { margin: 0; font-size: 24px; color: #8e44ad; }
        #score { font-size: 32px; font-weight: bold; color: #d35400; }

        .footer {
            padding: 20px;
            text-align: center;
            padding-bottom: 50px;
        }
        
        .btn {
            pointer-events: auto;
            background: #ff758c;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 117, 140, 0.4);
            transition: transform 0.1s;
        }

        .btn:active { transform: scale(0.95); }

    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div class="header">
            <h1>FASHION MATCH</h1>
            <div class="score-box">
                <span id="score">0</span>
            </div>
        </div>
        <div class="footer">
            <button class="btn" onclick="game.reset()">RESTART</button>
        </div>
    </div>
</div>

<script>
    // ÈÖçÁΩÆ
    const CONFIG = {
        cols: 7,
        rows: 9,
        tileSize: 130, // Âú® 1080 ÂÆΩÂ∫¶‰∏ãÁöÑÈÄªËæëÂ∞∫ÂØ∏
        designWidth: 1080,
        designHeight: 1920,
        colors: ['#FFC3A0', '#FF677D', '#D4A5A5', '#392F5A', '#31A2AC'], // Ë∞ÉËØïÁî®ËÉåÊôØËâ≤
        // ‰ΩøÁî® Emoji ‰Ωú‰∏∫Ê¨ßÁæéÂ•≥ÊÄßÂêëÈ£éÊ†ºÁöÑÂõæÊ†á
        icons: ['üíÑ', 'üë†', 'üíé', 'üëú', 'üéÄ', 'üßÅ']
    };

    // Easing functions for smooth animations
    const Easing = {
        // For smooth drops with bounce
        easeOutBounce: (t) => {
            if (t < 1 / 2.75) {
                return 7.5625 * t * t;
            } else if (t < 2 / 2.75) {
                return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            } else if (t < 2.5 / 2.75) {
                return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            } else {
                return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
            }
        },

        // For swap animations
        easeInOutQuad: (t) => {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        },

        // For fade-out effects
        easeOutCubic: (t) => {
            return (--t) * t * t + 1;
        },

        // For pop-in effects
        easeOutBack: (t) => {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        }
    };

    // Linear interpolation helper
    function lerp(start, end, t) {
        return start + (end - start) * t;
    }

    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.scoreElement = document.getElementById('score');
            
            // ËÆæÁΩÆÁîªÂ∏ÉÂàÜËæ®Áéá
            this.canvas.width = CONFIG.designWidth;
            this.canvas.height = CONFIG.designHeight;

            this.grid = [];
            this.score = 0;
            this.selectedTile = null;
            this.isProcessing = false; // Âä®Áîª/Â§ÑÁêÜ‰∏≠ÈîÅ
            this.particles = []; // Á≤íÂ≠êÁ≥ªÁªü

            // ËÆ°ÁÆóÁΩëÊ†ºÂú®ÁîªÂ∏É‰∏≠ÁöÑÂ±Ö‰∏≠‰ΩçÁΩÆ
            this.gridWidth = CONFIG.cols * CONFIG.tileSize;
            this.gridHeight = CONFIG.rows * CONFIG.tileSize;
            this.offsetX = (CONFIG.designWidth - this.gridWidth) / 2;
            this.offsetY = (CONFIG.designHeight - this.gridHeight) / 2 + 100; // Á®çÂæÆÈù†‰∏ã‰∏ÄÁÇπ

            // ÁªëÂÆö‰∫ã‰ª∂
            this.bindEvents();
            this.reset();
            this.loop();
        }

        reset() {
            this.score = 0;
            this.updateScoreUI();
            this.initGrid();
            // ÂàùÂßãÊ£ÄÊü•ÔºåÈÅøÂÖçÂºÄÂ±ÄÂ∞±ÊúâÊ∂àÈô§
            while(this.findMatches().length > 0) {
                this.initGrid();
            }
            this.draw();
        }

        initGrid() {
            this.grid = [];
            for (let r = 0; r < CONFIG.rows; r++) {
                this.grid[r] = [];
                for (let c = 0; c < CONFIG.cols; c++) {
                    this.grid[r][c] = {
                        type: Math.floor(Math.random() * CONFIG.icons.length),
                        x: c * CONFIG.tileSize,
                        y: r * CONFIG.tileSize,
                        alpha: 1,
                        offsetY: 0,
                        offsetX: 0,
                        // Animation properties
                        targetY: 0,
                        targetAlpha: undefined,
                        targetScale: undefined,
                        scale: 1,
                        animating: false,
                        animationProgress: 0,
                        animationDuration: 0,
                        animationStartTime: 0
                    };
                }
            }
        }

        bindEvents() {
            // ÂÖºÂÆπÈº†Ê†áÂíåËß¶Êë∏
            const handleInput = (e) => {
                if (this.isProcessing) return;

                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // ÂùêÊ†áËΩ¨Êç¢ÔºöÂ±èÂπïÂùêÊ†á -> ÁîªÂ∏ÉÈÄªËæëÂùêÊ†á
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                const x = (clientX - rect.left) * scaleX;
                const y = (clientY - rect.top) * scaleY;

                this.handleClick(x, y);
            };

            this.canvas.addEventListener('mousedown', handleInput);
            this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e); }, {passive: false});
        }

        handleClick(x, y) {
            // Âà§Êñ≠ÁÇπÂáªÊòØÂê¶Âú®ÁΩëÊ†ºÂÜÖ
            if (x < this.offsetX || x > this.offsetX + this.gridWidth ||
                y < this.offsetY || y > this.offsetY + this.gridHeight) {
                this.selectedTile = null;
                return;
            }

            const col = Math.floor((x - this.offsetX) / CONFIG.tileSize);
            const row = Math.floor((y - this.offsetY) / CONFIG.tileSize);

            if (this.selectedTile) {
                // Â¶ÇÊûúÊòØÂêå‰∏Ä‰∏™ÔºåÂèñÊ∂àÈÄâÊã©
                if (this.selectedTile.c === col && this.selectedTile.r === row) {
                    this.selectedTile = null;
                } else {
                    // Âà§Êñ≠ÊòØÂê¶Áõ∏ÈÇª
                    if (Math.abs(this.selectedTile.c - col) + Math.abs(this.selectedTile.r - row) === 1) {
                        this.swapTiles(this.selectedTile, {r: row, c: col});
                        this.selectedTile = null;
                    } else {
                        // ‰∏çÁõ∏ÈÇªÔºåÊõ¥Êñ∞ÈÄâÊã©
                        this.selectedTile = {r: row, c: col};
                    }
                }
            } else {
                this.selectedTile = {r: row, c: col};
            }
        }

        async swapTiles(tile1, tile2) {
            this.isProcessing = true;

            // Store original types
            const type1 = this.grid[tile1.r][tile1.c].type;
            const type2 = this.grid[tile2.r][tile2.c].type;

            // Animate swap with visual feedback
            await this.animateSwap(tile1, tile2);

            // Actually swap data
            this.grid[tile1.r][tile1.c].type = type2;
            this.grid[tile2.r][tile2.c].type = type1;

            await this.sleep(100);

            // Ê£ÄÊü•Ê∂àÈô§
            const matches = this.findMatches();

            if (matches.length > 0) {
                await this.processMatches(matches);
            } else {
                // Swap failed - animate back
                await this.animateSwap(tile1, tile2);
                this.grid[tile1.r][tile1.c].type = type1;
                this.grid[tile2.r][tile2.c].type = type2;
            }

            this.isProcessing = false;
        }

        // Helper method for swap animation
        async animateSwap(tile1, tile2) {
            const duration = 250;
            const startTime = Date.now();

            // Calculate offsets
            const dx1 = (tile2.c - tile1.c) * CONFIG.tileSize;
            const dy1 = (tile2.r - tile1.r) * CONFIG.tileSize;
            const dx2 = -dx1;
            const dy2 = -dy1;

            // Animate
            while (Date.now() - startTime < duration) {
                const progress = (Date.now() - startTime) / duration;
                const eased = Easing.easeInOutQuad(progress);

                this.grid[tile1.r][tile1.c].offsetX = dx1 * eased;
                this.grid[tile1.r][tile1.c].offsetY = dy1 * eased;
                this.grid[tile2.r][tile2.c].offsetX = dx2 * eased;
                this.grid[tile2.r][tile2.c].offsetY = dy2 * eased;

                await this.sleep(16); // ~60fps
            }

            // Reset offsets
            this.grid[tile1.r][tile1.c].offsetX = 0;
            this.grid[tile1.r][tile1.c].offsetY = 0;
            this.grid[tile2.r][tile2.c].offsetX = 0;
            this.grid[tile2.r][tile2.c].offsetY = 0;
        }

        // Create particle explosion effect
        createExplosion(row, col, tileType) {
            const centerX = this.offsetX + col * CONFIG.tileSize + CONFIG.tileSize / 2;
            const centerY = this.offsetY + row * CONFIG.tileSize + CONFIG.tileSize / 2;
            const particleCount = 15;
            const colors = ['#FF6B9D', '#FEC3A6', '#FFD93D', '#6BCF7F', '#A8E6CF', '#FF8B94'];

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 3 + Math.random() * 4;
                const size = 8 + Math.random() * 12;

                this.particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: size,
                    alpha: 1,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    life: 1,
                    decay: 0.015 + Math.random() * 0.015,
                    gravity: 0.15
                });
            }
        }

        // Update and draw particles
        updateParticles() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];

                // Update position
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity; // Apply gravity

                // Update life
                p.life -= p.decay;
                p.alpha = p.life;

                // Remove dead particles
                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                    continue;
                }

                // Draw particle
                this.ctx.save();
                this.ctx.globalAlpha = p.alpha;
                this.ctx.fillStyle = p.color;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
        }

        async processMatches(matches) {
            // 1. Ê∂àÈô§ÈÄªËæë
            let multiplier = 1;
            while (matches.length > 0) {
                // Start fade-out and shrink animation for matched tiles
                for (let m of matches) {
                    const tile = this.grid[m.r][m.c];

                    // Create explosion effect
                    this.createExplosion(m.r, m.c, tile.type);

                    tile.animating = true;
                    tile.targetAlpha = 0;
                    tile.targetScale = 0;
                    tile.animationProgress = 0;
                    tile.animationDuration = 300;
                    tile.animationStartTime = Date.now();
                }

                // Wait for fade-out animation to complete
                await this.sleep(350);

                // Now actually remove tiles
                for (let m of matches) {
                    this.grid[m.r][m.c].type = -1;
                    this.grid[m.r][m.c].alpha = 1;
                    this.grid[m.r][m.c].scale = 1;
                }

                // Âä†ÂàÜ
                this.score += matches.length * 10 * multiplier;
                this.updateScoreUI();
                multiplier++;

                // 2. ‰∏ãËêΩÈÄªËæë
                this.applyGravity();
                await this.waitForAnimations();

                // 3. Â°´ÂÖÖÊñ∞Âùó
                this.fillEmpty();
                await this.waitForAnimations();

                // 4. ÂÜçÊ¨°Ê£ÄÊü•
                matches = this.findMatches();
            }
        }

        applyGravity() {
            let hasMovement = false;

            for (let c = 0; c < CONFIG.cols; c++) {
                let emptySlots = 0;
                for (let r = CONFIG.rows - 1; r >= 0; r--) {
                    if (this.grid[r][c].type === -1) {
                        emptySlots++;
                    } else if (emptySlots > 0) {
                        // Calculate drop distance
                        const targetRow = r + emptySlots;
                        const dropDistance = emptySlots * CONFIG.tileSize;

                        // Move tile data
                        this.grid[targetRow][c].type = this.grid[r][c].type;
                        this.grid[targetRow][c].scale = this.grid[r][c].scale;

                        // Set up drop animation
                        this.grid[targetRow][c].offsetY = -dropDistance;
                        this.grid[targetRow][c].targetY = 0;
                        this.grid[targetRow][c].animating = true;
                        this.grid[targetRow][c].animationProgress = 0;
                        this.grid[targetRow][c].animationDuration = 400 + emptySlots * 50;
                        this.grid[targetRow][c].animationStartTime = Date.now();

                        // Clear source
                        this.grid[r][c].type = -1;
                        hasMovement = true;
                    }
                }
            }

            return hasMovement;
        }

        fillEmpty() {
            // Count empty slots in each column and spawn from top
            for (let c = 0; c < CONFIG.cols; c++) {
                let emptyCount = 0;
                let emptyPositions = [];

                // Find all empty positions in this column
                for (let r = 0; r < CONFIG.rows; r++) {
                    if (this.grid[r][c].type === -1) {
                        emptyCount++;
                        emptyPositions.push(r);
                    }
                }

                // Spawn new tiles from above and drop them down
                for (let i = 0; i < emptyCount; i++) {
                    const targetRow = emptyPositions[i];
                    const dropDistance = (targetRow + 1 + i) * CONFIG.tileSize;

                    // Spawn new tile
                    this.grid[targetRow][c].type = Math.floor(Math.random() * CONFIG.icons.length);

                    // Drop animation from above the grid
                    this.grid[targetRow][c].offsetY = -dropDistance;
                    this.grid[targetRow][c].targetY = 0;
                    this.grid[targetRow][c].scale = 1;
                    this.grid[targetRow][c].alpha = 1;
                    this.grid[targetRow][c].animating = true;
                    this.grid[targetRow][c].animationProgress = 0;
                    this.grid[targetRow][c].animationDuration = 400 + dropDistance / CONFIG.tileSize * 50;
                    this.grid[targetRow][c].animationStartTime = Date.now();
                }
            }
        }

        findMatches() {
            let matchedSet = new Set();

            // Ê®™ÂêëÊ£ÄÊü•
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols - 2; c++) {
                    let type = this.grid[r][c].type;
                    if (type === -1) continue;
                    if (this.grid[r][c+1].type === type && this.grid[r][c+2].type === type) {
                        matchedSet.add(`${r},${c}`);
                        matchedSet.add(`${r},${c+1}`);
                        matchedSet.add(`${r},${c+2}`);
                    }
                }
            }

            // Á∫µÂêëÊ£ÄÊü•
            for (let c = 0; c < CONFIG.cols; c++) {
                for (let r = 0; r < CONFIG.rows - 2; r++) {
                    let type = this.grid[r][c].type;
                    if (type === -1) continue;
                    if (this.grid[r+1][c].type === type && this.grid[r+2][c].type === type) {
                        matchedSet.add(`${r},${c}`);
                        matchedSet.add(`${r+1},${c}`);
                        matchedSet.add(`${r+2},${c}`);
                    }
                }
            }

            return Array.from(matchedSet).map(str => {
                let [r, c] = str.split(',').map(Number);
                return {r, c};
            });
        }

        updateScoreUI() {
            this.scoreElement.innerText = this.score;
        }

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async waitForAnimations() {
            while (true) {
                let hasAnimating = false;
                for (let r = 0; r < CONFIG.rows; r++) {
                    for (let c = 0; c < CONFIG.cols; c++) {
                        if (this.grid[r][c].animating) {
                            hasAnimating = true;
                            break;
                        }
                    }
                    if (hasAnimating) break;
                }
                if (!hasAnimating) break;
                await this.sleep(16);
            }
        }

        draw() {
            // Ê∏ÖÁ©∫ÁîªÂ∏É
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // ÁªòÂà∂ËÉåÊôØÁΩëÊ†ºÊùø
            this.ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            this.ctx.roundRect(this.offsetX - 20, this.offsetY - 20, this.gridWidth + 40, this.gridHeight + 40, 40);
            this.ctx.fill();

            // Update animations
            const now = Date.now();
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    let tile = this.grid[r][c];
                    if (tile.animating) {
                        const elapsed = now - tile.animationStartTime;
                        const progress = Math.min(elapsed / tile.animationDuration, 1);

                        // Apply easing for offsetY (drop animation)
                        if (tile.offsetY !== tile.targetY) {
                            const easedProgress = Easing.easeOutBounce(progress);
                            tile.offsetY = lerp(tile.offsetY, tile.targetY, easedProgress);
                        }

                        // Interpolate alpha (for fade effects)
                        if (tile.targetAlpha !== undefined) {
                            tile.alpha = lerp(tile.alpha, tile.targetAlpha, Easing.easeOutCubic(progress));
                        }

                        // Interpolate scale (for shrink/pop effects)
                        if (tile.targetScale !== undefined) {
                            tile.scale = lerp(tile.scale, tile.targetScale, Easing.easeOutBack(progress));
                        }

                        // Complete animation
                        if (progress >= 1) {
                            tile.animating = false;
                            tile.offsetY = tile.targetY;
                            if (tile.targetAlpha !== undefined) {
                                tile.alpha = tile.targetAlpha;
                                tile.targetAlpha = undefined;
                            }
                            if (tile.targetScale !== undefined) {
                                tile.scale = tile.targetScale;
                                tile.targetScale = undefined;
                            }
                        }
                    }
                }
            }

            // ÁªòÂà∂ÊñπÂùó
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    let tile = this.grid[r][c];
                    if (tile.type === -1) continue;

                    let x = this.offsetX + c * CONFIG.tileSize + (tile.offsetX || 0);
                    let y = this.offsetY + r * CONFIG.tileSize + (tile.offsetY || 0);

                    // Apply alpha
                    this.ctx.globalAlpha = tile.alpha;

                    // Apply scale (center-based scaling)
                    const scale = tile.scale || 1;
                    if (scale !== 1) {
                        this.ctx.save();
                        const centerX = x + CONFIG.tileSize / 2;
                        const centerY = y + CONFIG.tileSize / 2;
                        this.ctx.translate(centerX, centerY);
                        this.ctx.scale(scale, scale);
                        this.ctx.translate(-centerX, -centerY);
                    }

                    // ÁªòÂà∂ÊñπÂùóËÉåÊôØÔºàÂ¢ûÂä†Ë¥®ÊÑüÔºâ
                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                    if (this.selectedTile && this.selectedTile.r === r && this.selectedTile.c === c) {
                         this.ctx.fillStyle = "#fff0f5"; // ÈÄâ‰∏≠È´ò‰∫Æ
                         this.ctx.shadowBlur = 20;
                         this.ctx.shadowColor = "#ff69b4";
                    } else {
                        this.ctx.shadowBlur = 0;
                    }

                    // ÂúÜËßíÊñπÂùó
                    const padding = 10;
                    const size = CONFIG.tileSize - padding * 2;
                    this.ctx.beginPath();
                    this.ctx.roundRect(x + padding, y + padding, size, size, 25);
                    this.ctx.fill();

                    // ÁªòÂà∂ Emoji ÂõæÊ†á
                    this.ctx.font = "80px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    this.ctx.shadowBlur = 0; // ÊñáÂ≠ó‰∏çÂä†Èò¥ÂΩ±Ôºå‰øùÊåÅÊ∏ÖÊô∞
                    this.ctx.fillText(CONFIG.icons[tile.type], x + CONFIG.tileSize/2, y + CONFIG.tileSize/2 + 10);

                    // Restore context if scaled
                    if (scale !== 1) {
                        this.ctx.restore();
                    }

                    // Reset alpha
                    this.ctx.globalAlpha = 1;
                }
            }

            // Draw particles (on top of tiles)
            this.updateParticles();

            requestAnimationFrame(() => {}); // ‰øùÊåÅÂæ™ÁéØÈí©Â≠ê
        }
        
        loop() {
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    }

    // Ëß£ÂÜ≥ Canvas roundRect ÂÖºÂÆπÊÄß
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    }

    // ÂêØÂä®Ê∏∏Êàè
    const game = new Game();

</script>
</body>
</html>
