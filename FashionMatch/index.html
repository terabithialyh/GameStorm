<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fashion Match - æ—¶å°šæ¶ˆæ¶ˆä¹</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* æ¸¸æˆå®¹å™¨ï¼Œç»´æŒ 9:16 æ¯”ä¾‹ */
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 56.25vh; /* 9/16 = 0.5625 */
            background: linear-gradient(180deg, #FF9A9E 0%, #FECFEF 99%, #FECFEF 100%);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            padding: 20px;
            text-align: center;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .score-box {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            padding: 10px 30px;
            display: inline-block;
            margin-top: 10px;
            border: 3px solid #ff758c;
        }

        h1 { margin: 0; font-size: 24px; color: #8e44ad; }
        #score { font-size: 32px; font-weight: bold; color: #d35400; }

        .footer {
            padding: 20px;
            text-align: center;
            padding-bottom: 50px;
        }
        
        .btn {
            pointer-events: auto;
            background: #ff758c;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 117, 140, 0.4);
            transition: transform 0.1s;
        }

        .btn:active { transform: scale(0.95); }

    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div class="header">
            <h1>FASHION MATCH</h1>
            <div class="score-box">
                <span id="score">0</span>
            </div>
        </div>
        <div class="footer">
            <button class="btn" onclick="game.reset()">RESTART</button>
        </div>
    </div>
</div>

<script>
    // é…ç½®
    const CONFIG = {
        cols: 7,
        rows: 9,
        tileSize: 130, // åœ¨ 1080 å®½åº¦ä¸‹çš„é€»è¾‘å°ºå¯¸
        designWidth: 1080,
        designHeight: 1920,
        colors: ['#FFC3A0', '#FF677D', '#D4A5A5', '#392F5A', '#31A2AC'], // è°ƒè¯•ç”¨èƒŒæ™¯è‰²
        // ä½¿ç”¨ Emoji ä½œä¸ºæ¬§ç¾å¥³æ€§å‘é£æ ¼çš„å›¾æ ‡
        icons: ['ğŸ’„', 'ğŸ‘ ', 'ğŸ’', 'ğŸ‘œ', 'ğŸ€', 'ğŸ§'] 
    };

    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.scoreElement = document.getElementById('score');
            
            // è®¾ç½®ç”»å¸ƒåˆ†è¾¨ç‡
            this.canvas.width = CONFIG.designWidth;
            this.canvas.height = CONFIG.designHeight;

            this.grid = [];
            this.score = 0;
            this.selectedTile = null;
            this.isProcessing = false; // åŠ¨ç”»/å¤„ç†ä¸­é”

            // è®¡ç®—ç½‘æ ¼åœ¨ç”»å¸ƒä¸­çš„å±…ä¸­ä½ç½®
            this.gridWidth = CONFIG.cols * CONFIG.tileSize;
            this.gridHeight = CONFIG.rows * CONFIG.tileSize;
            this.offsetX = (CONFIG.designWidth - this.gridWidth) / 2;
            this.offsetY = (CONFIG.designHeight - this.gridHeight) / 2 + 100; // ç¨å¾®é ä¸‹ä¸€ç‚¹

            // ç»‘å®šäº‹ä»¶
            this.bindEvents();
            this.reset();
            this.loop();
        }

        reset() {
            this.score = 0;
            this.updateScoreUI();
            this.initGrid();
            // åˆå§‹æ£€æŸ¥ï¼Œé¿å…å¼€å±€å°±æœ‰æ¶ˆé™¤
            while(this.findMatches().length > 0) {
                this.initGrid();
            }
            this.draw();
        }

        initGrid() {
            this.grid = [];
            for (let r = 0; r < CONFIG.rows; r++) {
                this.grid[r] = [];
                for (let c = 0; c < CONFIG.cols; c++) {
                    this.grid[r][c] = {
                        type: Math.floor(Math.random() * CONFIG.icons.length),
                        x: c * CONFIG.tileSize,
                        y: r * CONFIG.tileSize,
                        alpha: 1,
                        offsetY: 0 // ç”¨äºä¸‹è½åŠ¨ç”»
                    };
                }
            }
        }

        bindEvents() {
            // å…¼å®¹é¼ æ ‡å’Œè§¦æ‘¸
            const handleInput = (e) => {
                if (this.isProcessing) return;

                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // åæ ‡è½¬æ¢ï¼šå±å¹•åæ ‡ -> ç”»å¸ƒé€»è¾‘åæ ‡
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                const x = (clientX - rect.left) * scaleX;
                const y = (clientY - rect.top) * scaleY;

                this.handleClick(x, y);
            };

            this.canvas.addEventListener('mousedown', handleInput);
            this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e); }, {passive: false});
        }

        handleClick(x, y) {
            // åˆ¤æ–­ç‚¹å‡»æ˜¯å¦åœ¨ç½‘æ ¼å†…
            if (x < this.offsetX || x > this.offsetX + this.gridWidth ||
                y < this.offsetY || y > this.offsetY + this.gridHeight) {
                this.selectedTile = null;
                return;
            }

            const col = Math.floor((x - this.offsetX) / CONFIG.tileSize);
            const row = Math.floor((y - this.offsetY) / CONFIG.tileSize);

            if (this.selectedTile) {
                // å¦‚æœæ˜¯åŒä¸€ä¸ªï¼Œå–æ¶ˆé€‰æ‹©
                if (this.selectedTile.c === col && this.selectedTile.r === row) {
                    this.selectedTile = null;
                } else {
                    // åˆ¤æ–­æ˜¯å¦ç›¸é‚»
                    if (Math.abs(this.selectedTile.c - col) + Math.abs(this.selectedTile.r - row) === 1) {
                        this.swapTiles(this.selectedTile, {r: row, c: col});
                        this.selectedTile = null;
                    } else {
                        // ä¸ç›¸é‚»ï¼Œæ›´æ–°é€‰æ‹©
                        this.selectedTile = {r: row, c: col};
                    }
                }
            } else {
                this.selectedTile = {r: row, c: col};
            }
        }

        async swapTiles(tile1, tile2) {
            this.isProcessing = true;
            
            // äº¤æ¢æ•°æ®
            const tempType = this.grid[tile1.r][tile1.c].type;
            this.grid[tile1.r][tile1.c].type = this.grid[tile2.r][tile2.c].type;
            this.grid[tile2.r][tile2.c].type = tempType;

            // ç®€å•æ¸²æŸ“ä¸€å¸§ä»¥æ˜¾ç¤ºäº¤æ¢ç»“æœ
            this.draw(); 
            await this.sleep(200);

            // æ£€æŸ¥æ¶ˆé™¤
            const matches = this.findMatches();
            
            if (matches.length > 0) {
                await this.processMatches(matches);
            } else {
                // äº¤æ¢å¤±è´¥ï¼Œæ¢å›æ¥
                const tempTypeRevert = this.grid[tile1.r][tile1.c].type;
                this.grid[tile1.r][tile1.c].type = this.grid[tile2.r][tile2.c].type;
                this.grid[tile2.r][tile2.c].type = tempTypeRevert;
            }
            
            this.isProcessing = false;
        }

        async processMatches(matches) {
            // 1. æ¶ˆé™¤é€»è¾‘
            let multiplier = 1;
            while (matches.length > 0) {
                // æ ‡è®°æ¶ˆé™¤
                for (let m of matches) {
                    this.grid[m.r][m.c].type = -1; // -1 ä»£è¡¨ç©º
                }
                
                // åŠ åˆ†
                this.score += matches.length * 10 * multiplier;
                this.updateScoreUI();
                multiplier++;

                this.draw();
                await this.sleep(300);

                // 2. ä¸‹è½é€»è¾‘
                this.applyGravity();
                this.draw();
                await this.sleep(300);

                // 3. å¡«å……æ–°å—
                this.fillEmpty();
                this.draw();
                await this.sleep(200);

                // 4. å†æ¬¡æ£€æŸ¥
                matches = this.findMatches();
            }
        }

        applyGravity() {
            for (let c = 0; c < CONFIG.cols; c++) {
                let emptySlots = 0;
                for (let r = CONFIG.rows - 1; r >= 0; r--) {
                    if (this.grid[r][c].type === -1) {
                        emptySlots++;
                    } else if (emptySlots > 0) {
                        // ç§»åŠ¨å½“å‰å—åˆ°ä¸‹é¢çš„ç©ºä½
                        this.grid[r + emptySlots][c].type = this.grid[r][c].type;
                        this.grid[r][c].type = -1;
                    }
                }
            }
        }

        fillEmpty() {
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    if (this.grid[r][c].type === -1) {
                        this.grid[r][c].type = Math.floor(Math.random() * CONFIG.icons.length);
                    }
                }
            }
        }

        findMatches() {
            let matchedSet = new Set();

            // æ¨ªå‘æ£€æŸ¥
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols - 2; c++) {
                    let type = this.grid[r][c].type;
                    if (type === -1) continue;
                    if (this.grid[r][c+1].type === type && this.grid[r][c+2].type === type) {
                        matchedSet.add(`${r},${c}`);
                        matchedSet.add(`${r},${c+1}`);
                        matchedSet.add(`${r},${c+2}`);
                    }
                }
            }

            // çºµå‘æ£€æŸ¥
            for (let c = 0; c < CONFIG.cols; c++) {
                for (let r = 0; r < CONFIG.rows - 2; r++) {
                    let type = this.grid[r][c].type;
                    if (type === -1) continue;
                    if (this.grid[r+1][c].type === type && this.grid[r+2][c].type === type) {
                        matchedSet.add(`${r},${c}`);
                        matchedSet.add(`${r+1},${c}`);
                        matchedSet.add(`${r+2},${c}`);
                    }
                }
            }

            return Array.from(matchedSet).map(str => {
                let [r, c] = str.split(',').map(Number);
                return {r, c};
            });
        }

        updateScoreUI() {
            this.scoreElement.innerText = this.score;
        }

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        draw() {
            // æ¸…ç©ºç”»å¸ƒ
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼æ¿
            this.ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            this.ctx.roundRect(this.offsetX - 20, this.offsetY - 20, this.gridWidth + 40, this.gridHeight + 40, 40);
            this.ctx.fill();

            // ç»˜åˆ¶æ–¹å—
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    let tile = this.grid[r][c];
                    if (tile.type === -1) continue;

                    let x = this.offsetX + c * CONFIG.tileSize;
                    let y = this.offsetY + r * CONFIG.tileSize;

                    // ç»˜åˆ¶æ–¹å—èƒŒæ™¯ï¼ˆå¢åŠ è´¨æ„Ÿï¼‰
                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                    if (this.selectedTile && this.selectedTile.r === r && this.selectedTile.c === c) {
                         this.ctx.fillStyle = "#fff0f5"; // é€‰ä¸­é«˜äº®
                         this.ctx.shadowBlur = 20;
                         this.ctx.shadowColor = "#ff69b4";
                    } else {
                        this.ctx.shadowBlur = 0;
                    }

                    // åœ†è§’æ–¹å—
                    const padding = 10;
                    const size = CONFIG.tileSize - padding * 2;
                    this.ctx.beginPath();
                    this.ctx.roundRect(x + padding, y + padding, size, size, 25);
                    this.ctx.fill();

                    // ç»˜åˆ¶ Emoji å›¾æ ‡
                    this.ctx.font = "80px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    this.ctx.shadowBlur = 0; // æ–‡å­—ä¸åŠ é˜´å½±ï¼Œä¿æŒæ¸…æ™°
                    this.ctx.fillText(CONFIG.icons[tile.type], x + CONFIG.tileSize/2, y + CONFIG.tileSize/2 + 10);
                }
            }

            requestAnimationFrame(() => {}); // ä¿æŒå¾ªç¯é’©å­
        }
        
        loop() {
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    }

    // è§£å†³ Canvas roundRect å…¼å®¹æ€§
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    }

    // å¯åŠ¨æ¸¸æˆ
    const game = new Game();

</script>
</body>
</html>
