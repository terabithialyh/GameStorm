<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Rookie Rise - èœé¸Ÿå´›èµ·</title>
  <style>
    :root {
      --ink: #101018;
      --paper: #ffffff;
      --bg1: #2f6bff;
      --bg2: #7b2cff;
      --accent: #ffcc00;
      --good: #35d07f;
      --bad: #ff5a6a;
      --panel: rgba(255, 255, 255, 0.92);
      --panel2: rgba(255, 255, 255, 0.15);
      --shadow: rgba(0, 0, 0, 0.25);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 30% 20%, rgba(255, 255, 255, 0.25), transparent 60%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
      color: white;
      user-select: none;
    }

    #root {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    #gameWrap {
      position: relative;
      width: min(980px, 100vw);
      height: 100vh;
      max-height: 100vh;
      padding: 14px 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    header {
      position: relative;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.18);
      border: 2px solid rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(10px);
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .brand h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.2px;
      text-shadow: 0 2px 0 rgba(0, 0, 0, 0.25);
    }

    .brand .sub {
      font-size: 12px;
      opacity: 0.9;
    }

    .hud {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      border: 2px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      font-size: 12px;
      white-space: nowrap;
    }

    .pill b {
      font-size: 14px;
    }

    .pill.good b {
      color: var(--good);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
    }

    .pill.bad b {
      color: var(--bad);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
    }

    .btnRow {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: none;
      touch-action: manipulation;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.06));
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.18);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
    }

    button.primary {
      background: linear-gradient(180deg, #ffd74b, #ffb300);
      color: #1c1600;
      border-color: rgba(0, 0, 0, 0.12);
    }

    button.danger {
      background: linear-gradient(180deg, #ff5a6a, #ff2f4c);
      color: white;
      border-color: rgba(0, 0, 0, 0.12);
    }

    #canvasWrap {
      position: relative;
      flex: 1;
      z-index: 1;
      touch-action: none;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.18);
      border: 2px solid rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #hint {
      position: absolute;
      left: 14px;
      bottom: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.12);
      border: 2px solid rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(10px);
      font-size: 12px;
      max-width: min(520px, calc(100% - 28px));
      line-height: 1.35;
      pointer-events: none;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: rgba(0, 0, 0, 0.58);
    }

    #overlay.show {
      display: flex;
    }

    .panel {
      width: min(680px, 100%);
      border-radius: 18px;
      background: var(--panel);
      color: var(--ink);
      border: 3px solid rgba(0, 0, 0, 0.15);
      box-shadow: 0 30px 70px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .panelHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 14px 10px;
      background: linear-gradient(180deg, rgba(255, 204, 0, 0.55), rgba(255, 204, 0, 0.15));
      border-bottom: 2px solid rgba(0, 0, 0, 0.12);
    }

    .panelHead .title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .panelHead .title b {
      font-size: 16px;
    }

    .panelHead .title span {
      font-size: 12px;
      opacity: 0.8;
    }

    .panelBody {
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .speaker {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 900;
      letter-spacing: 0.2px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.12);
      font-size: 12px;
      font-weight: 800;
    }

    .dialogText {
      font-size: 14px;
      line-height: 1.5;
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.04);
      border: 2px solid rgba(0, 0, 0, 0.08);
    }

    .metaRow {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .metaCard {
      border-radius: 14px;
      padding: 10px 10px;
      border: 2px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .metaCard .k {
      font-size: 11px;
      opacity: 0.75;
      font-weight: 800;
    }

    .metaCard .v {
      font-size: 14px;
      font-weight: 900;
    }

    .panelActions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px 14px;
      border-top: 2px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.85);
    }

    .panelActions .left,
    .panelActions .right {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    @media (max-width: 540px) {
      header {
        flex-direction: column;
        align-items: stretch;
      }

      .hud {
        justify-content: space-between;
      }

      .metaRow {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div id="root">
    <div id="gameWrap">
      <header>
        <div class="brand">
          <h1>ğŸ€ Rookie Rise</h1>
          <div class="sub">ä»é€‰ç§€èœé¸Ÿåˆ°çƒé˜Ÿé¢†è¢– Â· åŠåœºæŠ•ç¯®æŒ‘æˆ˜ï¼ˆæ»‘åŠ¨æŠ•ç¯®ï¼‰</div>
        </div>
        <div class="hud">
          <div class="pill"><span>æ¯”èµ›</span><b id="hudMatch">-</b></div>
          <div class="pill"><span>åˆ†æ•°</span><b id="hudScore">0</b></div>
          <div class="pill"><span>ç›®æ ‡</span><b id="hudTarget">0</b></div>
          <div class="pill"><span>æ—¶é—´</span><b id="hudTime">0.0</b></div>
          <div class="pill"><span>èƒ½åŠ›</span><b id="hudRating">60</b></div>
        </div>
        <div class="btnRow">
          <button id="btnStory">å‰§æƒ…</button>
          <button id="btnRestart" class="danger">é‡å¼€æœ¬åœº</button>
          <button id="btnStart" class="primary">å¼€å§‹</button>
        </div>
      </header>

      <div id="canvasWrap">
        <canvas id="c"></canvas>
        <div id="hint">
          æ“ä½œï¼š<b>å¿«é€Ÿç‚¹å‡»</b>è‡ªåŠ¨ç„å‡†æŠ•ç¯®ï¼ˆè·ç¦»è¶Šè¿œå‘½ä¸­ç‡è¶Šä½ï¼‰ï¼›<b>æŒ‰ä½æ‹–åŠ¨å†æ¾æ‰‹</b>æ‰‹åŠ¿æŠ•ç¯®ï¼ˆå·¦å³æ–¹å‘=æ°´å¹³åç§»ï¼Œå¼§åº¦åŠ›é‡=å‘ä¸Šæ‹–åŠ¨ï¼‰ã€‚<br />
          è®¡åˆ†ï¼šä¸‰åˆ†çº¿å†… 2 åˆ†ï¼Œä¸‰åˆ†çº¿å¤– 3 åˆ†ã€‚é™æ—¶è¾¾æˆç›®æ ‡å³å¯è§¦å‘æ–°å‰§æƒ…å¹¶è¿›å…¥ä¸‹ä¸€åœºã€‚
        </div>

        <div id="overlay">
          <div class="panel">
            <div class="panelHead">
              <div class="title">
                <b id="ovTitle">å‰§æƒ…</b>
                <span id="ovSub">â€”â€”</span>
              </div>
              <div class="badge" id="ovStep">1/1</div>
            </div>
            <div class="panelBody">
              <div class="speaker">
                <span id="ovAvatar">ğŸ§¢</span>
                <span id="ovSpeaker">æ—ç™½</span>
                <span class="badge" id="ovTag">åºç« </span>
              </div>
              <div class="dialogText" id="ovText"></div>
              <div class="metaRow" id="ovMetaRow">
                <div class="metaCard">
                  <div class="k">å¯¹æ‰‹</div>
                  <div class="v" id="ovOpponent">â€”</div>
                </div>
                <div class="metaCard">
                  <div class="k">ç›®æ ‡</div>
                  <div class="v" id="ovMetaTarget">â€”</div>
                </div>
                <div class="metaCard">
                  <div class="k">æ—¶é—´</div>
                  <div class="v" id="ovMetaTime">â€”</div>
                </div>
              </div>
            </div>
            <div class="panelActions">
              <div class="left">
                <button id="btnSkip">è·³è¿‡</button>
              </div>
              <div class="right">
                <button id="btnNext" class="primary">ä¸‹ä¸€å¥</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const now = () => performance.now();

      const vec3 = (x = 0, y = 0, z = 0) => ({ x, y, z });
      const vadd = (a, b) => vec3(a.x + b.x, a.y + b.y, a.z + b.z);
      const vsub = (a, b) => vec3(a.x - b.x, a.y - b.y, a.z - b.z);
      const vmul = (a, s) => vec3(a.x * s, a.y * s, a.z * s);
      const vdot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;
      const vlen = (a) => Math.hypot(a.x, a.y, a.z);
      const vnorm = (a) => {
        const L = vlen(a);
        if (L < 1e-9) return vec3(0, 0, 0);
        return vmul(a, 1 / L);
      };
      const vcross = (a, b) =>
        vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

      const audio = (() => {
        let ctx = null;
        const ensure = () => {
          if (ctx) return ctx;
          try {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
          } catch {
            ctx = null;
          }
          return ctx;
        };
        const beep = (type, freq, dur, gain) => {
          const ac = ensure();
          if (!ac) return;
          const t0 = ac.currentTime;
          const osc = ac.createOscillator();
          const g = ac.createGain();
          osc.type = type;
          osc.frequency.value = freq;
          g.gain.value = 0.0001;
          osc.connect(g);
          g.connect(ac.destination);
          osc.start(t0);
          g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
          osc.stop(t0 + dur + 0.02);
        };
        return {
          swish: () => beep("sine", 520, 0.09, 0.12),
          rim: () => beep("triangle", 240, 0.12, 0.14),
          board: () => beep("square", 160, 0.08, 0.08),
          score: () => beep("sine", 820, 0.14, 0.16),
          buzz: () => beep("sawtooth", 120, 0.25, 0.08),
        };
      })();

      // ====== ä¸–ç•Œä¸ç‰©ç†é…ç½® ======
      const WORLD = Object.freeze({
        COURT_W: 15.0,
        COURT_L: 14.0,
        SHOOT_Z_MAX: 16.8, // å…è®¸åœ¨åº•çº¿å¤–ä¸€ç‚¹å‡ºæ‰‹ï¼Œé¿å…è§¦æ‘¸é ä¸‹æ—¶è¢« clamp å¯¼è‡´â€œèµ·ç‚¹æ¼‚ç§»â€
        FLOOR_Y: 0.0,
        HOOP: vec3(0, 3.05, 0.0),
        BACKBOARD_Z: -0.65,
        BACKBOARD_W: 1.8,
        BACKBOARD_H: 1.2,
        BACKBOARD_Y0: 2.65,
        RIM_R: 0.23,
        BALL_R: 0.12,
        THREE_R: 7.24,
      });

      const PHYS = Object.freeze({
        G: -14.0, // ç¨å¾®å¤¸å¼ ä¸€äº›ï¼Œè®©æ‰‹æ„Ÿæ›´â€œæ¸¸æˆåŒ–â€ï¼Œä½†ä»åƒçœŸå®æŠ›ç‰©çº¿
        AIR_DRAG: 0.04,
        FLOOR_REST: 0.55,
        RIM_REST: 0.62,
        BOARD_REST: 0.68,
        WALL_REST: 0.45,
        FLOOR_FRICTION: 0.88,
        TANGENT_FRICTION: 0.92,
      });

      // ====== å‰§æƒ…ä¸æ¯”èµ›é…ç½® ======
      // çº¿æ€§å‰§æƒ…ï¼šæ¯åœºæ¯”èµ›å‰/åè§¦å‘å¯¹è¯ï¼Œèƒœåˆ©è¿›å…¥ä¸‹ä¸€åœºã€‚
      const CAMPAIGN = [
        {
          id: "draft_night",
          title: "é€‰ç§€ä¹‹å¤œ",
          tag: "åºç« ",
          pre: [
            { speaker: "æ—ç™½", avatar: "ğŸ“º", text: "é•å…‰ç¯æŠŠå¤œè‰²ç…§å¾—åƒç™½æ˜¼ã€‚ä»Šå¤©ï¼Œä½ çš„åå­—ä¼šè¢«å¿µå‡ºæ¥ã€‚", },
            { speaker: "ç»çºªäºº", avatar: "ğŸ§‘â€ğŸ’¼", text: "åˆ«ç´§å¼ ã€‚ä¸Šåœºåˆ«æƒ³å¤ªå¤šâ€”â€”æŠŠè®­ç»ƒé¦†çš„æ‰‹æ„Ÿå¸¦åˆ°çƒåœºã€‚", },
            { speaker: "ä½ ", avatar: "ğŸ§¢", text: "æˆ‘å‡†å¤‡å¥½äº†ã€‚æˆ‘è¦è®©æ‰€æœ‰äººè®°ä½ï¼šæˆ‘ä¸åªæ˜¯ä¸ªâ€œæ½œåŠ›è‚¡â€ã€‚", },
          ],
          match: { opponent: "å¤å­£è”èµ› Â· å¯¹æŠ—é˜Ÿ", time: 45, target: 14 },
          post: [
            { speaker: "æ•™ç»ƒ", avatar: "ğŸ§”â€â™‚ï¸", text: "ä¸é”™ï¼Œèœé¸Ÿã€‚ä½ æ•¢æŠ•ã€æ•¢æ‰¿æ‹…ï¼Œè¿™æ˜¯å¥½äº‹ã€‚ä¸‹ä¸€åœºï¼Œå‹åŠ›ä¼šæ›´å¤§ã€‚", },
          ],
        },
        {
          id: "bench_role",
          title: "æ›¿è¡¥å¸­çš„æœºä¼š",
          tag: "ç¬¬1ç« ",
          pre: [
            { speaker: "æ—ç™½", avatar: "ğŸ“°", text: "åª’ä½“è¯´ä½ åªä¼šé å¤©èµ‹åƒé¥­ã€‚ä½ å†³å®šç”¨æœ€æœ´ç´ çš„æ–¹å¼å›åº”ï¼šå¾—åˆ†ã€‚", },
            { speaker: "é˜Ÿå‹", avatar: "ğŸ˜", text: "åˆ«æ€•æ‰“é“ï¼Œå…³é”®æ˜¯æŠ•ç¯®é€‰æ‹©ã€‚æ‰¾åˆ°ä½ çš„ç”œç‚¹åŒºï¼Œç„¶åç‹ ç‹ å¹²ã€‚", },
          ],
          match: { opponent: "å¸¸è§„èµ› Â· å®¢åœº", time: 50, target: 18 },
          post: [
            { speaker: "æ—ç™½", avatar: "ğŸ“ˆ", text: "æ•°æ®ä¸ä¼šè¯´è°ã€‚ä½ åœ¨æœ‰é™çš„ä¸Šåœºæ—¶é—´é‡Œï¼Œæ‰“å‡ºäº†â€œå€¼å¾—æ›´å¤šä¿¡ä»»â€çš„è¡¨ç°ã€‚", },
          ],
        },
        {
          id: "closing_time",
          title: "å…³é”®æ—¶åˆ»",
          tag: "ç¬¬2ç« ",
          pre: [
            { speaker: "æ•™ç»ƒ", avatar: "ğŸ§”â€â™‚ï¸", text: "æœ€åä¸¤åˆ†é’Ÿæˆ‘æŠŠä½ ç•™åœ¨åœºä¸Šã€‚åˆ«çŠ¹è±«â€”â€”ç©ºä½å°±æŠ•ã€‚", },
            { speaker: "ä½ ", avatar: "ğŸ§¢", text: "ç»™æˆ‘çƒã€‚æˆ‘ä¼šåšå‡ºæ­£ç¡®çš„å†³å®šã€‚", },
          ],
          match: { opponent: "å¸¸è§„èµ› Â· å¼ºé˜Ÿ", time: 55, target: 22 },
          post: [
            { speaker: "è§£è¯´", avatar: "ğŸ™ï¸", text: "è¿™ä½æ–°ç§€â€”â€”ä»–ä¸åªæ˜¯æ•¢æŠ•ï¼Œä»–ä¼šåœ¨æœ€éš¾çš„æ—¶åˆ»åšå‡ºæœ€ç¡¬çš„å›åº”ï¼", },
          ],
        },
        {
          id: "leader",
          title: "çƒé˜Ÿé¢†è¢–",
          tag: "ç»ˆç« ",
          pre: [
            { speaker: "æ—ç™½", avatar: "ğŸŸï¸", text: "æ›´è¡£å®¤é‡Œå®‰é™å¾—èƒ½å¬è§å‘¼å¸ã€‚ä½ æœ›å‘é˜Ÿå‹ï¼šä»–ä»¬åœ¨ç­‰ä½ å¼€å£ã€‚", },
            { speaker: "ä½ ", avatar: "ğŸ§¢", text: "æˆ‘ä»¬ä¸ä¼šç­‰æœºä¼šæ¥æ•²é—¨ã€‚æˆ‘ä»¬è¦æŠŠé—¨è¸¢å¼€ã€‚â€”â€”ä¸Šåœºï¼Œèµ¢ä¸‹è¿™ä¸€åœºã€‚", },
          ],
          match: { opponent: "å­£åèµ› Â· ç”Ÿæ­»æˆ˜", time: 60, target: 26 },
          post: [
            { speaker: "æ—ç™½", avatar: "ğŸ†", text: "ä»é€‰ç§€èœé¸Ÿåˆ°çƒé˜Ÿé¢†è¢–ï¼Œä½ ç”¨æ¯ä¸€æ¬¡å‡ºæ‰‹æŠŠæ•…äº‹å†™è¿›äº†è®°åˆ†ç‰Œã€‚", },
            { speaker: "ç³»ç»Ÿ", avatar: "âœ¨", text: "é€šå…³ï¼ä½ å¯ä»¥ä»ä»»æ„ç« èŠ‚é‡æ–°å¼€å§‹æŒ‘æˆ˜ï¼Œåˆ·æ–°å‘½ä¸­ç‡ä¸è®°å½•ã€‚", },
          ],
        },
      ];

      const state = {
        mode: "boot", // boot | story | match | result
        chapterIndex: 0,
        storyQueue: [],
        storyPos: 0,
        rating: 60,
        netKick: 0,
        netPhase: 0,
        match: {
          running: false,
          timeLeft: 0,
          score: 0,
          target: 0,
          opponent: "",
          streak: 0,
          shots: 0,
          makes: 0,
        },
        aim: {
          active: false,
          pointerId: null,
          sx: 0,
          sy: 0,
          st: 0,
          cx: 0,
          cy: 0,
          moved: 0,
          startWorld: null,
          previewBall: null,
          longPressTimer: null,
          longPressed: false,
          forceManual: false,
        },
        balls: [],
        effects: [],
        firstPerson: {
          active: false,
          saved: null,
        },
        lastTs: 0,
        lastTick: 0,
      };

      // ====== Canvas / Camera ======
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      const camera = {
        pos: vec3(0.0, 4.8, WORLD.COURT_L + 4.2),
        target: vec3(0.0, 3.05, 0.0),
        up: vec3(0, 1, 0),
        f: 900,
        basis: null,
      };

      // ç”¨äºå°†â€œå±å¹•åæ ‡ -> çƒåœºå¹³é¢(x,z)â€åšç²¾ç¡®æ˜ å°„ï¼ˆä¸åœ°æ¿å››è¾¹å½¢ä¸¥æ ¼å¯¹é½ï¼‰
      const projectionMap = {
        ready: false,
        dpr: 1,
        H: null,
        Hinv: null,
      };

      function computeCameraBasis() {
        const forward = vnorm(vsub(camera.target, camera.pos));
        const right = vnorm(vcross(forward, camera.up));
        const up = vcross(right, forward);
        camera.basis = { forward, right, up };
      }

      function mat3Invert(m) {
        const a = m[0][0], b = m[0][1], c = m[0][2];
        const d = m[1][0], e = m[1][1], f = m[1][2];
        const g = m[2][0], h = m[2][1], i = m[2][2];
        const A = e * i - f * h;
        const B = -(d * i - f * g);
        const C = d * h - e * g;
        const D = -(b * i - c * h);
        const E = a * i - c * g;
        const F = -(a * h - b * g);
        const G = b * f - c * e;
        const H = -(a * f - c * d);
        const I = a * e - b * d;
        const det = a * A + b * B + c * C;
        if (Math.abs(det) < 1e-10) return null;
        const invDet = 1 / det;
        return [
          [A * invDet, D * invDet, G * invDet],
          [B * invDet, E * invDet, H * invDet],
          [C * invDet, F * invDet, I * invDet],
        ];
      }

      function solveLinearSystem(A, b) {
        const n = b.length;
        const M = A.map((row, r) => row.slice().concat([b[r]]));
        for (let col = 0; col < n; col++) {
          let pivot = col;
          for (let r = col + 1; r < n; r++) {
            if (Math.abs(M[r][col]) > Math.abs(M[pivot][col])) pivot = r;
          }
          if (Math.abs(M[pivot][col]) < 1e-12) return null;
          if (pivot !== col) {
            const tmp = M[col];
            M[col] = M[pivot];
            M[pivot] = tmp;
          }
          const div = M[col][col];
          for (let c = col; c <= n; c++) M[col][c] /= div;
          for (let r = 0; r < n; r++) {
            if (r === col) continue;
            const factor = M[r][col];
            if (Math.abs(factor) < 1e-12) continue;
            for (let c = col; c <= n; c++) M[r][c] -= factor * M[col][c];
          }
        }
        return M.map((row) => row[n]);
      }

      function computeHomography4(src, dst) {
        // src/dst: [{x,y}] å››å¯¹ç‚¹ã€‚è¿”å› 3x3 Hï¼Œä½¿å¾— dst ~ H * srcï¼ˆé½æ¬¡ï¼‰
        const A = [];
        const b = [];
        for (let k = 0; k < 4; k++) {
          const x = src[k].x, y = src[k].y;
          const u = dst[k].x, v = dst[k].y;
          A.push([x, y, 1, 0, 0, 0, -u * x, -u * y]);
          b.push(u);
          A.push([0, 0, 0, x, y, 1, -v * x, -v * y]);
          b.push(v);
        }
        const h = solveLinearSystem(A, b);
        if (!h) return null;
        return [
          [h[0], h[1], h[2]],
          [h[3], h[4], h[5]],
          [h[6], h[7], 1],
        ];
      }

      function applyHomography(H, x, y) {
        const X = H[0][0] * x + H[0][1] * y + H[0][2];
        const Y = H[1][0] * x + H[1][1] * y + H[1][2];
        const W = H[2][0] * x + H[2][1] * y + H[2][2];
        if (Math.abs(W) < 1e-9) return null;
        return { x: X / W, y: Y / W };
      }

      function project(p) {
        const { forward, right, up } = camera.basis;
        const v = vsub(p, camera.pos);
        const xCam = vdot(v, right);
        const yCam = vdot(v, up);
        const zCam = vdot(v, forward);
        if (zCam <= 0.05) return null;
        const sx = canvas.width * 0.5 + (xCam / zCam) * camera.f;
        const sy = canvas.height * 0.58 - (yCam / zCam) * camera.f;
        return { x: sx, y: sy, z: zCam };
      }

      function pxRadius(worldRadius, zCam) {
        return (worldRadius / zCam) * camera.f;
      }

      function resize() {
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(2, Math.floor(rect.width * dpr));
        canvas.height = Math.max(2, Math.floor(rect.height * dpr));
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        camera.f = Math.min(canvas.width, canvas.height) * 1.05;
        projectionMap.dpr = dpr;
        computeProjectionMap();
      }

      window.addEventListener("resize", resize);
      computeCameraBasis();
      resize();

      function computeProjectionMap() {
        // è®¡ç®—â€œçƒåœºå¹³é¢(x,z) -> å±å¹•åƒç´ (u,v)â€çš„å•åº”æ˜ å°„ï¼Œå¹¶ç¼“å­˜é€†æ˜ å°„ç”¨äºå±å¹•->ä¸–ç•Œ
        const hw = WORLD.COURT_W * 0.5;
        const L = WORLD.SHOOT_Z_MAX;
        const zN = -1.4;
        const world = [
          { x: -hw, y: L },
          { x: hw, y: L },
          { x: hw, y: zN },
          { x: -hw, y: zN },
        ];
        const scr = [
          // ç”¨ y = BALL_R å¹³é¢å»ºå›¾ï¼šè¿™æ ·æŠŠâ€œè§¦ç‚¹å±å¹•åæ ‡â€æ˜ å°„åˆ°â€œç¯®çƒä¸­å¿ƒæ‰€åœ¨å¹³é¢â€ï¼Œä¿è¯çƒå¿ƒè´´æ‰‹æŒ‡
          project(vec3(-hw, WORLD.BALL_R, L)),
          project(vec3(hw, WORLD.BALL_R, L)),
          project(vec3(hw, WORLD.BALL_R, zN)),
          project(vec3(-hw, WORLD.BALL_R, zN)),
        ];
        if (scr.some((p) => !p)) {
          projectionMap.ready = false;
          projectionMap.H = null;
          projectionMap.Hinv = null;
          return;
        }
        const dst = scr.map((p) => ({ x: p.x, y: p.y }));
        const H = computeHomography4(world, dst);
        const Hinv = H ? mat3Invert(H) : null;
        projectionMap.ready = !!Hinv;
        projectionMap.H = H;
        projectionMap.Hinv = Hinv;
      }

      // ====== UI ======
      const el = {
        hudMatch: document.getElementById("hudMatch"),
        hudScore: document.getElementById("hudScore"),
        hudTarget: document.getElementById("hudTarget"),
        hudTime: document.getElementById("hudTime"),
        hudRating: document.getElementById("hudRating"),
        btnStart: document.getElementById("btnStart"),
        btnRestart: document.getElementById("btnRestart"),
        btnStory: document.getElementById("btnStory"),
        overlay: document.getElementById("overlay"),
        ovTitle: document.getElementById("ovTitle"),
        ovSub: document.getElementById("ovSub"),
        ovStep: document.getElementById("ovStep"),
        ovAvatar: document.getElementById("ovAvatar"),
        ovSpeaker: document.getElementById("ovSpeaker"),
        ovTag: document.getElementById("ovTag"),
        ovText: document.getElementById("ovText"),
        ovOpponent: document.getElementById("ovOpponent"),
        ovMetaTarget: document.getElementById("ovMetaTarget"),
        ovMetaTime: document.getElementById("ovMetaTime"),
        btnNext: document.getElementById("btnNext"),
        btnSkip: document.getElementById("btnSkip"),
      };

      function updateHud() {
        el.hudMatch.textContent = `${state.chapterIndex + 1}/${CAMPAIGN.length}`;
        el.hudScore.textContent = `${state.match.score}`;
        el.hudTarget.textContent = `${state.match.target}`;
        el.hudTime.textContent = `${Math.max(0, state.match.timeLeft).toFixed(1)}s`;
        el.hudRating.textContent = `${state.rating}`;
      }

      function showOverlay(show) {
        el.overlay.classList.toggle("show", !!show);
      }

      function setOverlayScene(scene, stepText) {
        el.ovTitle.textContent = CAMPAIGN[state.chapterIndex].title;
        el.ovSub.textContent = CAMPAIGN[state.chapterIndex].match
          ? `${CAMPAIGN[state.chapterIndex].match.opponent}`
          : "â€”";
        el.ovStep.textContent = stepText;
        el.ovAvatar.textContent = scene.avatar || "ğŸ§¢";
        el.ovSpeaker.textContent = scene.speaker || "æ—ç™½";
        el.ovTag.textContent = CAMPAIGN[state.chapterIndex].tag || "";
        el.ovText.textContent = scene.text || "";
        const m = CAMPAIGN[state.chapterIndex].match;
        el.ovOpponent.textContent = m?.opponent ?? "â€”";
        el.ovMetaTarget.textContent = m ? `${m.target} åˆ†` : "â€”";
        el.ovMetaTime.textContent = m ? `${m.time} ç§’` : "â€”";
      }

      function openStory(queue) {
        state.mode = "story";
        state.storyQueue = queue.slice();
        state.storyPos = 0;
        showOverlay(true);
        renderStoryStep();
      }

      function renderStoryStep() {
        const total = state.storyQueue.length || 1;
        const idx = clamp(state.storyPos, 0, total - 1);
        const scene = state.storyQueue[idx] || { speaker: "æ—ç™½", avatar: "ğŸ“–", text: "" };
        setOverlayScene(scene, `${idx + 1}/${total}`);
        if (idx !== total - 1) {
          el.btnNext.textContent = "ä¸‹ä¸€å¥";
          return;
        }
        if (state._afterStory === "advance") {
          el.btnNext.textContent = "è¿›å…¥ä¸‹ä¸€åœº";
          return;
        }
        if (state._afterStory === "retry") {
          el.btnNext.textContent = "é‡å¼€æœ¬åœº";
          return;
        }
        el.btnNext.textContent = "å¼€å§‹æ¯”èµ›";
      }

      function closeStoryAndStartMatch() {
        showOverlay(false);
        startMatch();
      }

      function toNextChapterOrFreeplay() {
        if (state.chapterIndex < CAMPAIGN.length - 1) {
          state.chapterIndex += 1;
          openStory(CAMPAIGN[state.chapterIndex].pre);
          return;
        }
        // é€šå…³åï¼šå›åˆ°ç¬¬ä¸€ç« ï¼ˆå¯åå¤æŒ‘æˆ˜ï¼‰
        state.chapterIndex = 0;
        openStory(CAMPAIGN[state.chapterIndex].pre);
      }

      // ====== æ¯”èµ›æµç¨‹ ======
      function resetMatch() {
        const chapter = CAMPAIGN[state.chapterIndex];
        state.match.running = false;
        state.match.timeLeft = chapter.match.time;
        state.match.score = 0;
        state.match.target = chapter.match.target;
        state.match.opponent = chapter.match.opponent;
        state.match.streak = 0;
        state.match.shots = 0;
        state.match.makes = 0;
        state.balls.length = 0;
        state.aim.active = false;
        state.aim.previewBall = null;
        updateHud();
      }

      function startMatch() {
        resetMatch();
        state.mode = "match";
        state.match.running = true;
        state.lastTick = now();
        updateHud();
      }

      function endMatch(success) {
        state.match.running = false;
        state.mode = "result";
        audio.buzz();
        const chapter = CAMPAIGN[state.chapterIndex];
        if (success) {
          // å°å¹…æˆé•¿ï¼šå‘½ä¸­è¶Šå¤šï¼Œå¥–åŠ±è¶Šé«˜
          const acc = state.match.shots > 0 ? state.match.makes / state.match.shots : 0;
          const gain = Math.round(3 + acc * 7);
          state.rating = clamp(state.rating + gain, 50, 99);
          openStory(chapter.post);
          // åœ¨ post çš„æœ€åä¸€å¥ç‚¹â€œå¼€å§‹æ¯”èµ›â€ä¼šè¿›å…¥ä¸‹ä¸€ç« 
          // è¿™é‡Œç”¨ story çš„ next æ¥æ§åˆ¶
          state._afterStory = "advance";
        } else {
          openStory([
            { speaker: "æ—ç™½", avatar: "â±ï¸", text: "å“¨å£°å“èµ·ã€‚åˆ†æ•°è¿˜å·®ä¸€ç‚¹ç‚¹ã€‚å†æ¥ä¸€åœºï¼ŒæŠŠèŠ‚å¥æ‰¾å›æ¥ã€‚", },
            { speaker: "æ•™ç»ƒ", avatar: "ğŸ§”â€â™‚ï¸", text: "åˆ«ä½å¤´ã€‚è°ƒæ•´å‡ºæ‰‹ç‚¹ï¼Œç¨³ä½åŠ›é‡ã€‚é‡å¼€æœ¬åœºã€‚", },
          ]);
          state._afterStory = "retry";
        }
      }

      // ====== è¾“å…¥æ˜ å°„ ======
      function screenToCourt(sx, sy) {
        // è¿‘ä¼¼æ˜ å°„ï¼šå±å¹•ä¸‹æ–¹æ›´é è¿‘ä½ ï¼ˆz æ›´å¤§ï¼‰ï¼Œä¸Šæ–¹æ›´é è¿‘ç¯®ç­ï¼ˆz æ›´å°ï¼‰
        const w = canvas.getBoundingClientRect().width;
        const h = canvas.getBoundingClientRect().height;
        const nx = (sx / w) * 2 - 1;
        const ny = sy / h; // 0..1
        const x = nx * (WORLD.COURT_W * 0.48);
        const z = lerp(WORLD.COURT_L * 0.92, WORLD.COURT_L * 0.18, clamp(ny, 0, 1));
        return vec3(clamp(x, -WORLD.COURT_W * 0.48, WORLD.COURT_W * 0.48), WORLD.BALL_R, clamp(z, 0.2, WORLD.SHOOT_Z_MAX));
      }

      function rayFromScreen(sx, sy) {
        // æŠŠå±å¹•åæ ‡ï¼ˆCSS pxï¼‰è½¬æ¢ä¸ºä¸–ç•Œåæ ‡å°„çº¿ï¼ˆç›¸æœºåæ ‡ç³» -> ä¸–ç•Œåæ ‡ï¼‰
        // ç”¨äºæŠŠæ‰‹æŒ‡èµ·ç‚¹/ç»ˆç‚¹å¯é åœ°æ˜ å°„åˆ°çƒåœºå¹³é¢ï¼Œé¿å… offsetX/ç¼©æ”¾å¸¦æ¥çš„åç§»ã€‚
        const rect = canvas.getBoundingClientRect();
        const dpr = canvas.width / rect.width;
        const px = sx * dpr;
        const py = sy * dpr;
        const cx = canvas.width * 0.5;
        const cy = canvas.height * 0.58;

        const { forward, right, up } = camera.basis;
        const dx = (px - cx) / camera.f;
        const dy = (cy - py) / camera.f;
        const dir = vnorm(vadd(vadd(vmul(right, dx), vmul(up, dy)), forward));
        return { origin: camera.pos, dir };
      }

      function screenToCourtWorld(sx, sy, yPlane) {
        // é¦–é€‰ï¼šä½¿ç”¨å•åº”é€†å˜æ¢ï¼ˆä¸åœ°æ¿å››è¾¹å½¢ä¸¥æ ¼å¯¹é½ï¼‰
        if (projectionMap.ready && projectionMap.Hinv) {
          const rect = canvas.getBoundingClientRect();
          const dpr = canvas.width / rect.width;
          const px = sx * dpr;
          const py = sy * dpr;
          const w = applyHomography(projectionMap.Hinv, px, py);
          if (w) {
            return vec3(
              clamp(w.x, -WORLD.COURT_W * 0.48, WORLD.COURT_W * 0.48),
              yPlane,
              clamp(w.y, 0.2, WORLD.SHOOT_Z_MAX),
            );
          }
        }

        // å›é€€ï¼šå°„çº¿ä¸ y = yPlaneï¼ˆçƒåœºå¹³é¢ï¼‰æ±‚äº¤
        const ray = rayFromScreen(sx, sy);
        if (!ray) return null;
        if (Math.abs(ray.dir.y) < 1e-6) return null;
        const t = (yPlane - ray.origin.y) / ray.dir.y;
        if (t <= 0) return null;
        const hit = vadd(ray.origin, vmul(ray.dir, t));
        return vec3(
          clamp(hit.x, -WORLD.COURT_W * 0.48, WORLD.COURT_W * 0.48),
          yPlane,
          clamp(hit.z, 0.2, WORLD.SHOOT_Z_MAX),
        );
      }

      const INPUT = Object.freeze({
        TAP_MAX_MS: 170,
        TAP_MAX_PX: 12,
        LONGPRESS_MS: 280,
        LONGPRESS_MAX_PX: 10,
      });

      function swipeToVelocity(sx, sy, ex, ey, dtMs, fromPos, preview = false) {
        const dx = ex - sx;
        const dy = ey - sy;
        const dist = Math.hypot(dx, dy);
        const dt = clamp(dtMs / 1000, 0.04, 0.35);
        const speedPx = dist / dt;

        const smoothstep = (a, b, x) => {
          const t = clamp((x - a) / (b - a), 0, 1);
          return t * t * (3 - 2 * t);
        };

        // æ‰‹åŠ¿æŠ•ç¯®ï¼šx åç§»æ§åˆ¶å·¦å³æ–¹å‘ï¼Œy åç§»æ§åˆ¶å¼§åº¦/åŠ›é‡
        const rect = canvas.getBoundingClientRect();
        const maxDx = Math.max(140, rect.width * 0.45);
        const maxDy = Math.max(160, rect.height * 0.6);
        const dx01 = clamp(dx / maxDx, -1, 1);
        const dyUp = clamp(sy - ey, 0, maxDy);
        const pLen = smoothstep(10, maxDy, dyUp);
        const pSpd = smoothstep(420, 2400, speedPx);
        const power01 = Math.pow(clamp(pLen * 0.75 + pSpd * 0.25, 0, 1), 0.9);

        const baseDir = vnorm(vec3(WORLD.HOOP.x - fromPos.x, 0, WORLD.HOOP.z - fromPos.z));
        const maxAngle = Math.PI * 0.16;
        const ang = dx01 * maxAngle;
        const cosA = Math.cos(ang);
        const sinA = Math.sin(ang);
        const dir = vnorm(vec3(baseDir.x * cosA - baseDir.z * sinA, 0, baseDir.x * sinA + baseDir.z * cosA));

        // è·ç¦»è¡¥å¿ï¼šæŠ•å¾—æ›´è¿œï¼Œéœ€è¦æ›´é«˜çš„åˆé€Ÿåº¦/å¼§çº¿
        const d = Math.hypot(fromPos.x - WORLD.HOOP.x, fromPos.z - WORLD.HOOP.z);
        const distFactor = clamp((d - 2.5) / 10.0, 0, 1);

        const rating01 = clamp((state.rating - 50) / 50, 0, 1);
        // æ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œå°½é‡å°‘â€œè‡ªåŠ¨ä¿®æ­£â€ï¼Œåªä¿ç•™å¾ˆè½»å¾®çš„æ•£å¸ƒï¼ˆè¶Šå¼ºåŠ›ã€èƒ½åŠ›è¶Šé«˜è¶Šç¨³ï¼‰
        const maxErr = (lerp(0.16, 0.05, rating01) + (1 - power01) * 0.06) * 0.7;
        const err = 0;
        const cos = Math.cos(err);
        const sin = Math.sin(err);
        const dirErr = vnorm(vec3(dir.x * cos - dir.z * sin, 0, dir.x * sin + dir.z * cos));

        // æ°´å¹³åˆé€Ÿåº¦ï¼šæ ¹æ®åŠ›é‡å’Œè·ç¦»ï¼Œé™åˆ¶ä¸Šé™é¿å…â€œç«ç®­çƒâ€
        const baseH = lerp(7.0, 12.6, power01) + distFactor * 2.1;
        const vH = clamp(baseH, 6.2, 16.8);

        // å‚ç›´åˆé€Ÿåº¦ï¼šéšè·ç¦»æ›´â€œæŠ›â€ï¼ŒéšåŠ›é‡æ›´é«˜
        const baseV = lerp(7.4, 16.2, power01) + distFactor * 3.4;
        const vy = clamp(baseV, 6.8, 19.2);

        const vx = dirErr.x * vH;
        const vz = dirErr.z * vH;
        return vec3(vx, vy, vz);
      }

      function enterFirstPerson(fromPos) {
        if (state.firstPerson.active) return;
        state.firstPerson.saved = {
          pos: vec3(camera.pos.x, camera.pos.y, camera.pos.z),
          target: vec3(camera.target.x, camera.target.y, camera.target.z),
        };
        const target = vec3(WORLD.HOOP.x, WORLD.HOOP.y + 0.1, WORLD.HOOP.z);
        const forward = vnorm(vsub(target, fromPos));
        const back = 0.6;
        const up = 0.35;
        camera.pos = vec3(fromPos.x - forward.x * back, fromPos.y + up, fromPos.z - forward.z * back);
        camera.target = target;
        computeCameraBasis();
        computeProjectionMap();
        state.firstPerson.active = true;
      }

      function exitFirstPerson() {
        if (!state.firstPerson.active || !state.firstPerson.saved) return;
        camera.pos = vec3(state.firstPerson.saved.pos.x, state.firstPerson.saved.pos.y, state.firstPerson.saved.pos.z);
        camera.target = vec3(state.firstPerson.saved.target.x, state.firstPerson.saved.target.y, state.firstPerson.saved.target.z);
        state.firstPerson.saved = null;
        computeCameraBasis();
        computeProjectionMap();
        state.firstPerson.active = false;
      }

      function getAimOrigin(fromPos) {
        if (!state.firstPerson.active || !camera.basis) return fromPos;
        return vadd(fromPos, vmul(camera.basis.forward, 0.35));
      }

      function autoAimVelocityAndChance(fromPos) {
        // è‡ªåŠ¨ç„å‡†ï¼šç”¨â€œå¸¦ç©ºæ°”é˜»åŠ›çš„è§£æè§£â€åˆé€Ÿåº¦ + æ•°å€¼æ ¡å‡†ï¼Œç¡®ä¿çœŸå®è¿‡æ¡†
        const d = Math.hypot(fromPos.x - WORLD.HOOP.x, fromPos.z - WORLD.HOOP.z);
        const dist01 = clamp((d - 2.0) / 10.0, 0, 1);
        const chance = 1;

        const kx = PHYS.AIR_DRAG;
        const ky = PHYS.AIR_DRAG * 0.3;
        const solveV0 = (d0, t, k) => {
          if (k < 1e-6) return d0 / t;
          const e = Math.exp(-k * t);
          return d0 * k / (1 - e);
        };
        const solveV0Y = (d0, t, k, g) => {
          if (k < 1e-6) return (d0 - 0.5 * g * t * t) / t;
          const e = Math.exp(-k * t);
          return (d0 * k - g * t) / (1 - e) + g / k;
        };

        const evaluateShot = (v0, tMax) => {
          const pos = vec3(fromPos.x, fromPos.y, fromPos.z);
          const vel = vec3(v0.x, v0.y, v0.z);
          let prev = vec3(pos.x, pos.y, pos.z);
          let prevY = pos.y;
          const dt = 1 / 120;
          for (let t = 0; t < tMax; t += dt) {
            vel.x *= 1 - PHYS.AIR_DRAG * dt;
            vel.y *= 1 - PHYS.AIR_DRAG * dt * 0.3;
            vel.z *= 1 - PHYS.AIR_DRAG * dt;
            vel.y += PHYS.G * dt;
            pos.x += vel.x * dt;
            pos.y += vel.y * dt;
            pos.z += vel.z * dt;
            if (prevY > WORLD.HOOP.y && pos.y <= WORLD.HOOP.y) {
              const tFrac = (prevY - WORLD.HOOP.y) / Math.max(1e-6, (prevY - pos.y));
              const x = prev.x + (pos.x - prev.x) * tFrac;
              const z = prev.z + (pos.z - prev.z) * tFrac;
              const r = Math.hypot(x - WORLD.HOOP.x, z - WORLD.HOOP.z);
              return r;
            }
            prev = vec3(pos.x, pos.y, pos.z);
            prevY = pos.y;
          }
          return Infinity;
        };

        const simulateScore = (v0) => {
          const ball = {
            pos: vec3(fromPos.x, fromPos.y, fromPos.z),
            vel: vec3(v0.x, v0.y, v0.z),
            prevY: fromPos.y,
          };
          const dt = 1 / 120;
          const tMax = 2.6;
          for (let t = 0; t < tMax; t += dt) {
            ball.prevY = ball.pos.y;

            ball.vel.x *= 1 - PHYS.AIR_DRAG * dt;
            ball.vel.y *= 1 - PHYS.AIR_DRAG * dt * 0.3;
            ball.vel.z *= 1 - PHYS.AIR_DRAG * dt;
            ball.vel.y += PHYS.G * dt;

            ball.pos.x += ball.vel.x * dt;
            ball.pos.y += ball.vel.y * dt;
            ball.pos.z += ball.vel.z * dt;

            // ç¯®æ¿ç¢°æ’ï¼ˆä¸å®æœºä¸€è‡´ï¼‰
            const bz = WORLD.BACKBOARD_Z;
            const inBoardX = Math.abs(ball.pos.x - WORLD.HOOP.x) <= WORLD.BACKBOARD_W * 0.5 + WORLD.BALL_R;
            const inBoardY = ball.pos.y >= WORLD.BACKBOARD_Y0 - WORLD.BALL_R &&
              ball.pos.y <= WORLD.BACKBOARD_Y0 + WORLD.BACKBOARD_H + WORLD.BALL_R;
            const crossedBoard = ball.pos.z - bz <= WORLD.BALL_R && (ball.pos.z - ball.vel.z * dt) - bz > WORLD.BALL_R;
            if (crossedBoard && inBoardX && inBoardY) {
              ball.pos.z = bz + WORLD.BALL_R;
              ball.vel.z = -ball.vel.z * PHYS.BOARD_REST;
              ball.vel.x *= 0.97;
            }

            // ç¯®ç­ç¢°æ’ï¼ˆç¦»æ•£ç‚¹è¿‘ä¼¼ï¼‰
            for (const p of rimPoints) {
              resolveSpherePoint(ball, p, 0.03, PHYS.RIM_REST, PHYS.TANGENT_FRICTION, null);
            }

            // è¿›çƒåˆ¤å®šï¼ˆä¸å®æœºä¸€è‡´ï¼‰
            const y0 = ball.prevY;
            const y1 = ball.pos.y;
            if (y0 > WORLD.HOOP.y + 0.02 && y1 <= WORLD.HOOP.y - 0.02) {
              const dx = ball.pos.x - WORLD.HOOP.x;
              const dz = ball.pos.z - WORLD.HOOP.z;
              const r = Math.hypot(dx, dz);
              if (r <= WORLD.RIM_R - WORLD.BALL_R * 0.35) {
                return true;
              }
            }

            if (ball.pos.y < WORLD.BALL_R - 0.2) break;
          }
          return false;
        };

        const T0 = lerp(0.78, 1.20, dist01);
        const lift0 = lerp(0.60, 0.85, dist01);
        let best = { r: Infinity, v: null };
        const tMin = Math.max(0.6, T0 - 0.18);
        const tMax = T0 + 0.28;
        const liftMin = Math.max(0.45, lift0 - 0.12);
        const liftMax = lift0 + 0.28;
        const tSteps = 6;
        const lSteps = 6;

        for (let i = 0; i <= tSteps; i++) {
          const T = lerp(tMin, tMax, i / tSteps);
          for (let j = 0; j <= lSteps; j++) {
            const lift = lerp(liftMin, liftMax, j / lSteps);
            const target = vec3(WORLD.HOOP.x, WORLD.HOOP.y + lift, WORLD.HOOP.z);
            const dx = target.x - fromPos.x;
            const dz = target.z - fromPos.z;
            const dy = target.y - fromPos.y;
            const vx = solveV0(dx, T, kx);
            const vz = solveV0(dz, T, kx);
            const vy = solveV0Y(dy, T, ky, PHYS.G);
            const v0 = vec3(vx, vy, vz);
            if (simulateScore(v0)) {
              return { vel: v0, chance, dist01 };
            }
            const r = evaluateShot(v0, T + 0.6);
            const safeR = WORLD.RIM_R - WORLD.BALL_R * 0.6;
            const penalty = r > safeR ? (r - safeR) * 3.0 : 0;
            const score = r + penalty;
            if (score < best.r) best = { r: score, v: v0 };
          }
        }

        if (best.v) {
          return { vel: best.v, chance, dist01 };
        }

        // å›é€€ï¼šè§£æè§£ç›´æ¥å‘½ä¸­ç¯®å¿ƒ
        const target = vec3(WORLD.HOOP.x, WORLD.HOOP.y + lift0, WORLD.HOOP.z);
        const dx = target.x - fromPos.x;
        const dz = target.z - fromPos.z;
        const dy = target.y - fromPos.y;
        const vx = solveV0(dx, T0, kx);
        const vz = solveV0(dz, T0, kx);
        const vy = solveV0Y(dy, T0, ky, PHYS.G);
        return { vel: vec3(vx, vy, vz), chance, dist01 };
      }

      function pointsForShot(fromPos) {
        const d = Math.hypot(fromPos.x - WORLD.HOOP.x, fromPos.z - WORLD.HOOP.z);
        return d >= WORLD.THREE_R ? 3 : 2;
      }

      // ====== Ball ======
      function makeBall(pos, vel, points) {
        return {
          id: Math.random().toString(16).slice(2),
          pos: vec3(pos.x, pos.y, pos.z),
          vel: vec3(vel.x, vel.y, vel.z),
          points,
          held: false,
          auto: false,
          willMake: false,
          scored: false,
          alive: true,
          age: 0,
          prevY: pos.y,
          wasAboveRim: pos.y > WORLD.HOOP.y + 0.15,
          spin: (Math.random() * 2 - 1) * 14,
        };
      }

      const rimPoints = (() => {
        const pts = [];
        const N = 18;
        for (let i = 0; i < N; i++) {
          const a = (i / N) * Math.PI * 2;
          pts.push(vec3(Math.cos(a) * WORLD.RIM_R, WORLD.HOOP.y, Math.sin(a) * WORLD.RIM_R));
        }
        return pts;
      })();

      function spawnImpact(pos, kind) {
        state.effects.push({
          pos: vec3(pos.x, pos.y, pos.z),
          age: 0,
          dur: 0.28,
          kind,
        });
      }

      function resolveSpherePoint(ball, point, pointR, restitution, tangentFriction, sfx) {
        const dx = ball.pos.x - point.x;
        const dy = ball.pos.y - point.y;
        const dz = ball.pos.z - point.z;
        const dist = Math.hypot(dx, dy, dz);
        const minDist = WORLD.BALL_R + pointR;
        if (dist <= 1e-6 || dist >= minDist) return false;
        const nx = dx / dist;
        const ny = dy / dist;
        const nz = dz / dist;

        // æ¨å‡ºç©¿é€
        const pen = minDist - dist;
        ball.pos.x += nx * pen;
        ball.pos.y += ny * pen;
        ball.pos.z += nz * pen;

        // é€Ÿåº¦åå°„
        const vDot = ball.vel.x * nx + ball.vel.y * ny + ball.vel.z * nz;
        if (vDot < 0) {
          ball.vel.x -= (1 + restitution) * vDot * nx;
          ball.vel.y -= (1 + restitution) * vDot * ny;
          ball.vel.z -= (1 + restitution) * vDot * nz;

          // åˆ‡å‘æ‘©æ“¦ï¼ˆç®€åŒ–ï¼‰
          ball.vel.x *= tangentFriction;
          ball.vel.z *= tangentFriction;
        }

        if (sfx) sfx();
        return true;
      }

      function tickBall(ball, dt) {
        ball.age += dt;
        ball.prevY = ball.pos.y;

        // ç©ºæ°”é˜»åŠ›
        ball.vel.x *= 1 - PHYS.AIR_DRAG * dt;
        ball.vel.y *= 1 - PHYS.AIR_DRAG * dt * 0.3;
        ball.vel.z *= 1 - PHYS.AIR_DRAG * dt;

        // è‡ªåŠ¨ç„å‡†â€œæ¦‚ç‡å‘½ä¸­â€è¾…åŠ©ï¼šä»…åœ¨æ¥è¿‘ç¯®ç­ã€ä¸‹è½é˜¶æ®µè½»å¾®æ‹‰å‘ç¯®å¿ƒ
        if (ball.auto && ball.willMake && ball.vel.y < 0 && ball.pos.y > WORLD.HOOP.y - 0.35) {
          const dx = WORLD.HOOP.x - ball.pos.x;
          const dz = WORLD.HOOP.z - ball.pos.z;
          const d = Math.hypot(dx, dz);
          if (d < 3.0) {
            const pull = clamp((3.0 - d) / 3.0, 0, 1);
            const ax = (dx / Math.max(1e-6, d)) * (12.0 * pull);
            const az = (dz / Math.max(1e-6, d)) * (12.0 * pull);
            ball.vel.x += ax * dt;
            ball.vel.z += az * dt;
          }
        }

        // é‡åŠ›
        ball.vel.y += PHYS.G * dt;

        // ç§¯åˆ†
        ball.pos.x += ball.vel.x * dt;
        ball.pos.y += ball.vel.y * dt;
        ball.pos.z += ball.vel.z * dt;

        // è¾¹ç•Œï¼šå·¦å³å¢™
        const xMin = -WORLD.COURT_W * 0.5 + WORLD.BALL_R;
        const xMax = WORLD.COURT_W * 0.5 - WORLD.BALL_R;
        if (ball.pos.x < xMin) {
          ball.pos.x = xMin;
          ball.vel.x = -ball.vel.x * PHYS.WALL_REST;
          audio.rim();
          spawnImpact(ball.pos, "wall");
        } else if (ball.pos.x > xMax) {
          ball.pos.x = xMax;
          ball.vel.x = -ball.vel.x * PHYS.WALL_REST;
          audio.rim();
          spawnImpact(ball.pos, "wall");
        }

        // è¾¹ç•Œï¼šå‰åï¼ˆå…è®¸ç•¥è¿‡ç¯®ç­åæ–¹ï¼‰
        const zMin = -2.0 + WORLD.BALL_R;
        const zMax = WORLD.SHOOT_Z_MAX + 1.0 - WORLD.BALL_R;
        if (ball.pos.z < zMin) {
          ball.pos.z = zMin;
          ball.vel.z = -ball.vel.z * PHYS.WALL_REST;
          audio.rim();
          spawnImpact(ball.pos, "wall");
        } else if (ball.pos.z > zMax) {
          ball.pos.z = zMax;
          ball.vel.z = -ball.vel.z * PHYS.WALL_REST;
          audio.rim();
          spawnImpact(ball.pos, "wall");
        }

        // åœ°é¢
        const yMin = WORLD.BALL_R;
        if (ball.pos.y < yMin) {
          ball.pos.y = yMin;
          if (ball.vel.y < -0.5) audio.rim();
          ball.vel.y = -ball.vel.y * PHYS.FLOOR_REST;
          ball.vel.x *= PHYS.FLOOR_FRICTION;
          ball.vel.z *= PHYS.FLOOR_FRICTION;
          if (Math.abs(ball.vel.y) < 0.55) ball.vel.y = 0;
        }

        // ç¯®æ¿ï¼ˆå¹³é¢ z = BACKBOARD_Zï¼‰
        const bz = WORLD.BACKBOARD_Z;
        const inBoardX = Math.abs(ball.pos.x - WORLD.HOOP.x) <= WORLD.BACKBOARD_W * 0.5 + WORLD.BALL_R;
        const inBoardY = ball.pos.y >= WORLD.BACKBOARD_Y0 - WORLD.BALL_R &&
          ball.pos.y <= WORLD.BACKBOARD_Y0 + WORLD.BACKBOARD_H + WORLD.BALL_R;
        const crossedBoard = ball.pos.z - bz <= WORLD.BALL_R && (ball.pos.z - ball.vel.z * dt) - bz > WORLD.BALL_R;
        if (crossedBoard && inBoardX && inBoardY) {
          ball.pos.z = bz + WORLD.BALL_R;
          ball.vel.z = -ball.vel.z * PHYS.BOARD_REST;
          ball.vel.x *= 0.97;
          audio.board();
          spawnImpact(ball.pos, "board");
        }

        // ç¯®ç­ï¼ˆç¦»æ•£ç‚¹è¿‘ä¼¼ï¼‰
        let rimHit = false;
        for (const p of rimPoints) {
          if (resolveSpherePoint(ball, p, 0.03, PHYS.RIM_REST, PHYS.TANGENT_FRICTION, audio.rim)) {
            rimHit = true;
          }
        }
        if (rimHit) {
          spawnImpact(ball.pos, "rim");
        }

        // è¿›çƒåˆ¤å®šï¼šä»ä¸Šç©¿è¿‡ç¯®ç­å¹³é¢å¹¶è½ä¸‹
        const y0 = ball.prevY;
        const y1 = ball.pos.y;
        if (!ball.scored && y0 > WORLD.HOOP.y + 0.02 && y1 <= WORLD.HOOP.y - 0.02) {
          const dx = ball.pos.x - WORLD.HOOP.x;
          const dz = ball.pos.z - WORLD.HOOP.z;
          const r = Math.hypot(dx, dz);
          const scoreR = ball.auto && ball.willMake
            ? WORLD.RIM_R + WORLD.BALL_R * 0.25
            : WORLD.RIM_R - WORLD.BALL_R * 0.35;
          if (r <= scoreR) {
            ball.scored = true;
            return "score";
          }
        }

        // ç”Ÿå‘½æœŸï¼šå¤ªä¹…æˆ–é€Ÿåº¦å¤ªä½å°±å›æ”¶
        const v = vlen(ball.vel);
        if (ball.age > 7.0 || (ball.age > 1.2 && v < 0.6 && ball.pos.y <= WORLD.BALL_R + 0.01)) {
          ball.alive = false;
        }

        return null;
      }

      // ====== æ¸²æŸ“ï¼ˆæ¬§ç¾å¡é€šé£æ ¼ï¼šé«˜é¥±å’Œ + ç²—æè¾¹ï¼‰ ======
      function drawBackground() {
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, "rgba(255,255,255,0.10)");
        g.addColorStop(1, "rgba(0,0,0,0.22)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // æ¼«ç”»å…‰æ–‘
        ctx.save();
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = "white";
        for (let i = 0; i < 6; i++) {
          const x = (0.12 + i * 0.16) * canvas.width;
          const y = (0.10 + (i % 2) * 0.07) * canvas.height;
          ctx.beginPath();
          ctx.arc(x, y, canvas.width * 0.05, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawCourt() {
        const y = 0;
        const hw = WORLD.COURT_W * 0.5;
        const L = WORLD.SHOOT_Z_MAX; // åœ°æ¿å»¶ä¼¸åˆ°å‡ºæ‰‹åŒºï¼Œé¿å…è§†è§‰ä¸Šâ€œçƒåœ¨åœºå¤–æ¼‚ç§»â€
        const corners = [
          vec3(-hw, y, L),
          vec3(hw, y, L),
          vec3(hw, y, -1.4),
          vec3(-hw, y, -1.4),
        ].map(project);
        if (corners.some((p) => !p)) return;

        // åœ°æ¿
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(corners[0].x, corners[0].y);
        for (let i = 1; i < corners.length; i++) ctx.lineTo(corners[i].x, corners[i].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.fill();
        ctx.lineWidth = Math.max(2, canvas.width * 0.0022);
        ctx.strokeStyle = "rgba(0,0,0,0.30)";
        ctx.stroke();

        // æœ¨åœ°æ¿æ¡çº¹ï¼ˆç®€åŒ–ï¼‰
        ctx.globalAlpha = 0.10;
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = Math.max(1, canvas.width * 0.0012);
        const stripes = 9;
        for (let i = 1; i < stripes; i++) {
          const x = lerp(-hw, hw, i / stripes);
          const p0 = project(vec3(x, 0, L));
          const p1 = project(vec3(x, 0, -1.4));
          if (!p0 || !p1) continue;
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.stroke();
        }
        ctx.restore();

        // ä¸‰åˆ†çº¿ï¼ˆåŠåœ†å¼§ + ç›´çº¿ï¼‰
        ctx.save();
        ctx.lineWidth = Math.max(2, canvas.width * 0.0022);
        ctx.strokeStyle = "rgba(255,255,255,0.65)";
        ctx.shadowColor = "rgba(0,0,0,0.25)";
        ctx.shadowBlur = 10;
        ctx.beginPath();

        const arcPts = [];
        const N = 40;
        const r = WORLD.THREE_R;
        // åªç”»åŠåœºé‡Œå¯è§çš„ä¸€æ®µå¼§çº¿
        for (let i = 0; i <= N; i++) {
          const a = lerp(-Math.PI * 0.92, Math.PI * 0.92, i / N);
          const x = Math.cos(a) * r;
          const z = Math.sin(a) * r;
          if (z < -0.2) continue;
          arcPts.push(vec3(x, 0.01, z));
        }
        for (let i = 0; i < arcPts.length; i++) {
          const p = project(arcPts[i]);
          if (!p) continue;
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.restore();
      }

      function drawBackboardAndHoop() {
        // ç¯®æ¿
        const x0 = -WORLD.BACKBOARD_W * 0.5;
        const x1 = WORLD.BACKBOARD_W * 0.5;
        const y0 = WORLD.BACKBOARD_Y0;
        const y1 = WORLD.BACKBOARD_Y0 + WORLD.BACKBOARD_H;
        const z = WORLD.BACKBOARD_Z;
        const quad = [vec3(x0, y0, z), vec3(x1, y0, z), vec3(x1, y1, z), vec3(x0, y1, z)].map(project);
        if (!quad.some((p) => !p)) {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(quad[0].x, quad[0].y);
          for (let i = 1; i < quad.length; i++) ctx.lineTo(quad[i].x, quad[i].y);
          ctx.closePath();
          ctx.fillStyle = "rgba(255,255,255,0.92)";
          ctx.fill();
          ctx.lineWidth = Math.max(2, canvas.width * 0.0022);
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.stroke();

          // å°æ–¹æ¡†
          const boxW = 0.6;
          const boxH = 0.45;
          const bq = [
            vec3(-boxW * 0.5, WORLD.HOOP.y + 0.18 - boxH * 0.5, z + 0.001),
            vec3(boxW * 0.5, WORLD.HOOP.y + 0.18 - boxH * 0.5, z + 0.001),
            vec3(boxW * 0.5, WORLD.HOOP.y + 0.18 + boxH * 0.5, z + 0.001),
            vec3(-boxW * 0.5, WORLD.HOOP.y + 0.18 + boxH * 0.5, z + 0.001),
          ].map(project);
          if (!bq.some((p) => !p)) {
            ctx.beginPath();
            ctx.moveTo(bq[0].x, bq[0].y);
            for (let i = 1; i < bq.length; i++) ctx.lineTo(bq[i].x, bq[i].y);
            ctx.closePath();
            ctx.lineWidth = Math.max(2, canvas.width * 0.0018);
            ctx.strokeStyle = "rgba(255, 64, 64, 0.9)";
            ctx.stroke();
          }
          ctx.restore();
        }

        // ç¯®ç­ï¼ˆç”»ç¯ï¼‰
        ctx.save();
        ctx.lineWidth = Math.max(3, canvas.width * 0.0030);
        ctx.strokeStyle = "rgba(255, 80, 70, 0.95)";
        ctx.shadowColor = "rgba(0,0,0,0.25)";
        ctx.shadowBlur = 12;
        ctx.beginPath();
        const N = 42;
        for (let i = 0; i <= N; i++) {
          const a = (i / N) * Math.PI * 2;
          const p = project(vec3(Math.cos(a) * WORLD.RIM_R, WORLD.HOOP.y, Math.sin(a) * WORLD.RIM_R));
          if (!p) continue;
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // ç½‘ï¼ˆæ¼«ç”»æ„Ÿï¼šå‡ æ¡çº¿ï¼‰
        // æ›´çœŸå®çš„ç½‘å…œï¼šä¸Šä¸‹ä¸¤åœˆ + çºµçº¿ + æ–œå‘äº¤ç»‡ï¼Œå¹¶åœ¨è¿›çƒæ—¶è½»å¾®æ‘†åŠ¨
        const kick = state.netKick;
        const phase = state.netPhase;
        const topR = WORLD.RIM_R * 0.94;
        const botR = WORLD.RIM_R * 0.38;
        const netDepth = 0.62;
        const seg = 16;

        const topRing = [];
        const botRing = [];
        for (let i = 0; i <= seg; i++) {
          const a = (i / seg) * Math.PI * 2;
          topRing.push(vec3(Math.cos(a) * topR, WORLD.HOOP.y, Math.sin(a) * topR));
          const sway = kick * 0.06 * Math.sin(a * 2 + phase);
          botRing.push(vec3(Math.cos(a) * botR, WORLD.HOOP.y - netDepth + sway, Math.sin(a) * botR));
        }

        ctx.save();
        ctx.globalAlpha = 0.62;
        ctx.lineWidth = Math.max(1.1, canvas.width * 0.00115);
        ctx.strokeStyle = "rgba(255,255,255,0.92)";
        ctx.shadowColor = "rgba(0,0,0,0.15)";
        ctx.shadowBlur = 8;

        const strokeRing = (ring) => {
          ctx.beginPath();
          for (let i = 0; i < ring.length; i++) {
            const p = project(ring[i]);
            if (!p) continue;
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
        };

        // åœˆ
        ctx.globalAlpha = 0.45;
        strokeRing(topRing);
        ctx.globalAlpha = 0.35;
        strokeRing(botRing);

        // çºµçº¿ + æ–œçº¿ï¼ˆäº¤ç»‡ï¼‰
        ctx.globalAlpha = 0.55;
        const strands = 12;
        for (let i = 0; i < strands; i++) {
          const a = (i / strands) * Math.PI * 2;
          const a2 = a + (Math.PI * 2) / (strands * 2);
          const top = vec3(Math.cos(a) * topR, WORLD.HOOP.y, Math.sin(a) * topR);
          const bot = vec3(Math.cos(a) * botR, WORLD.HOOP.y - netDepth + kick * 0.06 * Math.sin(a * 2 + phase), Math.sin(a) * botR);
          const bot2 = vec3(Math.cos(a2) * botR, WORLD.HOOP.y - netDepth + kick * 0.06 * Math.sin(a2 * 2 + phase), Math.sin(a2) * botR);

          const pTop = project(top);
          const pBot = project(bot);
          const pBot2 = project(bot2);
          if (pTop && pBot) {
            ctx.beginPath();
            ctx.moveTo(pTop.x, pTop.y);
            ctx.lineTo(pBot.x, pBot.y);
            ctx.stroke();
          }
          // æ–œå‘äº¤ç»‡
          if (pTop && pBot2) {
            ctx.globalAlpha = 0.28;
            ctx.beginPath();
            ctx.moveTo(pTop.x, pTop.y);
            ctx.lineTo(pBot2.x, pBot2.y);
            ctx.stroke();
            ctx.globalAlpha = 0.55;
          }
        }
        ctx.restore();
        ctx.restore();
      }

      function drawBall(ball) {
        const p = project(ball.pos);
        if (!p) return;
        const r = Math.max(2, pxRadius(WORLD.BALL_R, p.z));

        // é˜´å½±ï¼ˆè½åœ¨åœ°é¢ï¼‰
        const shadowP = project(vec3(ball.pos.x, WORLD.BALL_R, ball.pos.z));
        if (shadowP) {
          const h = clamp((ball.pos.y - WORLD.BALL_R) / 5.0, 0, 1);
          const sr = r * lerp(1.25, 0.65, h);
          ctx.save();
          ctx.globalAlpha = lerp(0.22, 0.06, h);
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.beginPath();
          ctx.ellipse(shadowP.x, shadowP.y + r * 0.25, sr, sr * 0.55, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // çƒä½“
        ctx.save();
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 140, 60, 1)";
        ctx.fill();
        ctx.lineWidth = Math.max(2, r * 0.18);
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.stroke();

        // é«˜å…‰
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(p.x - r * 0.28, p.y - r * 0.30, r * 0.22, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // ç¯®çƒçº¹è·¯ï¼ˆç®€åŒ–ï¼šä¸¤æ¡å¼§ + ä¸€æ¡ç«–çº¿ï¼‰
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = Math.max(1.3, r * 0.10);
        ctx.beginPath();
        ctx.arc(p.x, p.y, r * 0.92, -Math.PI * 0.25, Math.PI * 0.25);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(p.x, p.y, r * 0.92, Math.PI * 0.75, Math.PI * 1.25);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - r);
        ctx.lineTo(p.x, p.y + r);
        ctx.stroke();

        // å‘½ä¸­æç¤º
        if (ball.scored) {
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = "rgba(53, 208, 127, 0.95)";
          ctx.font = `900 ${Math.max(14, r * 1.2)}px ui-sans-serif, system-ui, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(`+${ball.points}`, p.x, p.y - r * 1.9);
        }
        ctx.restore();
      }

      function drawEffects() {
        if (!state.effects.length) return;
        const colors = {
          wall: "rgba(120, 200, 255, 1)",
          rim: "rgba(255, 200, 120, 1)",
          board: "rgba(255, 255, 255, 1)",
        };
        for (const fx of state.effects) {
          const p = project(fx.pos);
          if (!p) continue;
          const t = clamp(fx.age / fx.dur, 0, 1);
          const alpha = 1 - t;
          const r = Math.max(6, canvas.width * 0.01) * lerp(0.6, 1.8, t);
          ctx.save();
          ctx.globalAlpha = alpha * 0.9;
          ctx.strokeStyle = colors[fx.kind] || "rgba(255,255,255,1)";
          ctx.lineWidth = Math.max(2, canvas.width * 0.002);
          ctx.shadowColor = ctx.strokeStyle;
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawAim() {
        if (!state.aim.active) return;
        const sx = state.aim.sx;
        const sy = state.aim.sy;
        const cx = state.aim.cx;
        const cy = state.aim.cy;

        const moved = state.aim.moved;
        if (moved < 6) return;

        // ç”¨â€œçœŸå®æŠ•ç¯®æ–¹å‘â€ç”»è¾…åŠ©çº¿ï¼Œé¿å…æ‰‹åŠ¿æ–¹å‘ä¸å®é™…è½¨è¿¹ä¸ä¸€è‡´
        const dtMs = now() - state.aim.st;
        const from = state.aim.startWorld || (screenToCourtWorld(sx, sy, WORLD.BALL_R) || screenToCourt(sx, sy));
        const vel = swipeToVelocity(sx, sy, cx, cy, dtMs, from, true);
        const dir = vnorm(vec3(vel.x, 0, vel.z));
        const len = clamp(Math.hypot(vel.x, vel.z) * 0.18, 1.2, 3.5);

        const drawFrom = getAimOrigin(from);
        const p0 = project(vec3(drawFrom.x, drawFrom.y, drawFrom.z));
        const p1 = project(vec3(drawFrom.x + dir.x * len, drawFrom.y, drawFrom.z + dir.z * len));
        if (!p0 || !p1) return;

        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const L = Math.hypot(dx, dy);
        if (L < 6) return;

        ctx.save();
        ctx.lineWidth = Math.max(3, canvas.width * 0.0032);
        ctx.strokeStyle = "rgba(255, 204, 0, 0.9)";
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();

        // ç®­å¤´
        const ux = dx / L;
        const uy = dy / L;
        const ax = p1.x;
        const ay = p1.y;
        const head = Math.max(16, canvas.width * 0.02);
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax - ux * head - uy * head * 0.55, ay - uy * head + ux * head * 0.55);
        ctx.lineTo(ax - ux * head + uy * head * 0.55, ay - uy * head - ux * head * 0.55);
        ctx.closePath();
        ctx.fillStyle = "rgba(255, 204, 0, 0.95)";
        ctx.fill();
        ctx.restore();
      }

      function drawScoreBanner() {
        if (state.mode !== "match") return;
        // åªåœ¨æ¥è¿‘ç»“æŸæ—¶æç¤º
        if (state.match.timeLeft > 6.0) return;
        const need = Math.max(0, state.match.target - state.match.score);
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(0, 0, canvas.width, Math.max(46, canvas.height * 0.09));
        ctx.fillStyle = "white";
        ctx.font = `900 ${Math.max(18, canvas.width * 0.022)}px ui-sans-serif, system-ui, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(need <= 0 ? "è¾¾æ ‡ï¼ç¨³ä½ï¼" : `è¿˜å·® ${need} åˆ†ï¼`, canvas.width / 2, Math.max(24, canvas.height * 0.045));
        ctx.restore();
      }

      function drawTrajectoryPreview() {
        if (!state.aim.active) return;
        if (!state.aim.previewBall) return;
        if (state.mode !== "match" || !state.match.running) return;
        // è½»ç‚¹ï¼ˆè‡ªåŠ¨ç„å‡†ï¼‰ä¸ç”»é¢„è§ˆ
        if (state.aim.moved <= INPUT.TAP_MAX_PX) return;

        const dtMs = now() - state.aim.st;
        const from = state.aim.startWorld || state.aim.previewBall.pos;
        const drawFrom = getAimOrigin(from);
        const vel = swipeToVelocity(state.aim.sx, state.aim.sy, state.aim.cx, state.aim.cy, dtMs, from, true);

        // ç®€åŒ–å¼¹é“ï¼šä¸è€ƒè™‘ç¢°æ’ï¼ŒåªåšæŠ›ç‰©çº¿é¢„ä¼°ï¼Œè¶³å¤Ÿç”¨äºâ€œæ„Ÿè§‰â€ä¸ç„å‡†
        const tMax = 1.4;
        const steps = 18;
        const pts = [];
        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * tMax;
          const x = drawFrom.x + vel.x * t;
          const z = drawFrom.z + vel.z * t;
          const y = drawFrom.y + vel.y * t + 0.5 * PHYS.G * t * t;
          if (y < WORLD.BALL_R) break;
          pts.push(vec3(x, y, z));
        }
        if (pts.length < 2) return;

        ctx.save();
        // å…ˆç”»æŸ”å’Œå…‰æ™•
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = Math.max(5, canvas.width * 0.004);
        ctx.strokeStyle = "rgba(255, 204, 0, 0.55)";
        ctx.shadowColor = "rgba(0,0,0,0.25)";
        ctx.shadowBlur = 14;
        ctx.beginPath();
        let started = false;
        for (const w of pts) {
          const p = project(w);
          if (!p) continue;
          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // ç”»è™šçº¿ä¸»è½¨è¿¹
        ctx.globalAlpha = 0.9;
        ctx.lineWidth = Math.max(2, canvas.width * 0.0022);
        ctx.setLineDash([Math.max(6, canvas.width * 0.012), Math.max(6, canvas.width * 0.010)]);
        ctx.strokeStyle = "rgba(255, 240, 190, 0.95)";
        ctx.beginPath();
        started = false;
        for (const w of pts) {
          const p = project(w);
          if (!p) continue;
          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // ç»ˆç‚¹æç¤ºç‚¹
        const last = pts[pts.length - 1];
        const pl = project(last);
        if (pl) {
          const r = Math.max(4, canvas.width * 0.007);
          ctx.fillStyle = "rgba(255, 204, 0, 0.95)";
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = Math.max(2, canvas.width * 0.002);
          ctx.beginPath();
          ctx.arc(pl.x, pl.y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
      }

      // ====== ä¸»å¾ªç¯ ======
      function tick(ts) {
        if (!state.lastTs) state.lastTs = ts;
        const dt = clamp((ts - state.lastTs) / 1000, 0.0, 0.033);
        state.lastTs = ts;

        state.netPhase += dt * 6.0;
        state.netKick *= Math.exp(-dt * 5.0);

        if (state.mode === "match" && state.match.running) {
          state.match.timeLeft -= dt;
          if (state.match.timeLeft <= 0) {
            state.match.timeLeft = 0;
            updateHud();
            endMatch(state.match.score >= state.match.target);
          }
        }

        // ç‰©ç†æ›´æ–°ï¼ˆmatch æ—¶æ‰æ›´æ–°ï¼›story æ—¶å†»ç»“ç”»é¢ï¼‰
        if (state.mode === "match" && state.match.running) {
          for (const ball of state.balls) {
            if (ball.held) continue;
            const evt = tickBall(ball, dt);
            if (evt === "score") {
              state.match.score += ball.points;
              state.match.makes += 1;
              state.match.streak += 1;
              state.netKick = 1.0;
              audio.score();
              updateHud();
              if (state.match.score >= state.match.target) {
                // æå‰èƒœåˆ©ï¼šç«‹å³è§¦å‘ç»“ç®—
                endMatch(true);
                break;
              }
            }
          }
          state.balls = state.balls.filter((b) => b.alive);
        }

        if (state.effects.length) {
          for (const fx of state.effects) fx.age += dt;
          state.effects = state.effects.filter((fx) => fx.age < fx.dur);
        }

        render();
        requestAnimationFrame(tick);
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawCourt();
        drawBackboardAndHoop();
        drawTrajectoryPreview();

        // æŒ‰æ·±åº¦æ’åºï¼ˆzCam å¤§ = æ›´è¿œï¼Œåº”è¯¥å…ˆç”»ï¼›è¿‘çš„åç”»ï¼‰
        const drawList = state.balls
          .map((b) => {
            const p = project(b.pos);
            return p ? { b, z: p.z } : null;
          })
          .filter(Boolean)
          .sort((a, b) => b.z - a.z);

        for (const item of drawList) drawBall(item.b);

        drawEffects();
        drawAim();
        drawScoreBanner();
      }

      // ====== äº¤äº’ ======
      function canShoot() {
        return state.mode === "match" && state.match.running;
      }

      function getClientPointFromEvent(e) {
        // ç»Ÿä¸€ pointer/touch/mouse åæ ‡ï¼Œè¿”å› client åæ ‡ï¼ˆCSS pxï¼‰
        if (e.touches && e.touches.length) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        if (e.changedTouches && e.changedTouches.length) {
          return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      function getLocalPointFromClient(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        return {
          x: clamp(x, 0, rect.width),
          y: clamp(y, 0, rect.height),
        };
      }

      function getLocalPoint(e) {
        const p = getClientPointFromEvent(e);
        return getLocalPointFromClient(p.x, p.y);
      }

      function onPointerDown(e) {
        if (!canShoot()) return;
        if (state.aim.active) return;
        const p = getLocalPoint(e);
        const startWorld = screenToCourtWorld(p.x, p.y, WORLD.BALL_R) || screenToCourt(p.x, p.y);
        state.aim.active = true;
        state.aim.pointerId = e.pointerId;
        state.aim.sx = p.x;
        state.aim.sy = p.y;
        state.aim.cx = p.x;
        state.aim.cy = p.y;
        state.aim.st = now();
        state.aim.startWorld = startWorld;
        state.aim.moved = 0;
        state.aim.longPressed = false;
        state.aim.forceManual = false;
        if (state.aim.longPressTimer) {
          clearTimeout(state.aim.longPressTimer);
          state.aim.longPressTimer = null;
        }
        state.aim.longPressTimer = setTimeout(() => {
          if (!state.aim.active) return;
          if (state.aim.moved > INPUT.LONGPRESS_MAX_PX) return;
          state.aim.longPressed = true;
          state.aim.forceManual = true;
          enterFirstPerson(state.aim.startWorld || startWorld);
        }, INPUT.LONGPRESS_MS);

        try {
          canvasWrap.setPointerCapture(e.pointerId);
        } catch { }

        const preview = makeBall(startWorld, vec3(0, 0, 0), pointsForShot(startWorld));
        preview.held = true;
        preview.alive = true;
        preview.scored = false;
        state.aim.previewBall = preview;
        // èµ·ç‚¹ç”Ÿæˆç¯®çƒï¼šç«‹å³åŠ å…¥æ¸²æŸ“åˆ—è¡¨ï¼Œä½† release å‰ä¸è¿åŠ¨
        state.balls.push(preview);
        audio.swish();
      }

      function onPointerMove(e) {
        if (!state.aim.active) return;
        if (e.pointerId !== state.aim.pointerId) return;
        const p = getLocalPoint(e);
        state.aim.cx = p.x;
        state.aim.cy = p.y;
        state.aim.moved = Math.max(state.aim.moved, Math.hypot(state.aim.cx - state.aim.sx, state.aim.cy - state.aim.sy));
        if (state.aim.moved > INPUT.LONGPRESS_MAX_PX && state.aim.longPressTimer) {
          clearTimeout(state.aim.longPressTimer);
          state.aim.longPressTimer = null;
        }
      }

      function onPointerUp(e) {
        if (!state.aim.active) return;
        if (e.pointerId !== state.aim.pointerId) return;
        const p = getLocalPoint(e);
        if (state.aim.longPressTimer) {
          clearTimeout(state.aim.longPressTimer);
          state.aim.longPressTimer = null;
        }

        const t1 = now();
        const dtMs = t1 - state.aim.st;
        const sx = state.aim.sx;
        const sy = state.aim.sy;
        const ex = p.x;
        const ey = p.y;

        const preview = state.aim.previewBall;
        if (preview) {
          // èµ·ç‚¹ä¸¥æ ¼ä½¿ç”¨ pointerdown æ—¶çš„ä¸–ç•Œåæ ‡ï¼ˆé¿å…å¤šæ¬¡æ˜ å°„é€ æˆåå·®ï¼‰
          const pos = state.aim.startWorld || (screenToCourtWorld(sx, sy, WORLD.BALL_R) || screenToCourt(sx, sy));
          preview.pos.x = pos.x;
          preview.pos.y = pos.y;
          preview.pos.z = pos.z;

          preview.held = false;
          const isTap = dtMs <= INPUT.TAP_MAX_MS && state.aim.moved <= INPUT.TAP_MAX_PX && !state.aim.forceManual;
          if (isTap) {
            const { vel, chance, dist01 } = autoAimVelocityAndChance(pos);
            preview.auto = true;
            preview.willMake = Math.random() < chance;
            // æœªå‘½ä¸­ï¼šåŠ å¤§æ°´å¹³åå·®ï¼Œè®©â€œè¿œæŠ•æ›´éš¾â€
            if (!preview.willMake) {
              const missAngle = lerp(0.10, 0.35, dist01) * (Math.random() < 0.5 ? -1 : 1);
              const c = Math.cos(missAngle);
              const s = Math.sin(missAngle);
              const vx = vel.x * c - vel.z * s;
              const vz = vel.x * s + vel.z * c;
              preview.vel.x = vx;
              preview.vel.y = vel.y * lerp(0.98, 0.92, dist01);
              preview.vel.z = vz;
            } else {
              preview.vel.x = vel.x;
              preview.vel.y = vel.y;
              preview.vel.z = vel.z;
            }
          } else {
            const vel = swipeToVelocity(sx, sy, ex, ey, dtMs, pos);
            preview.auto = false;
            preview.willMake = false;
            preview.vel.x = vel.x;
            preview.vel.y = vel.y;
            preview.vel.z = vel.z;
          }
          preview.points = pointsForShot(pos);
          preview.age = 0;
          preview.prevY = preview.pos.y;
          preview.scored = false;

          state.match.shots += 1;
        }

        state.aim.active = false;
        state.aim.pointerId = null;
        state.aim.previewBall = null;
        state.aim.startWorld = null;
        state.aim.moved = 0;
        state.aim.longPressed = false;
        state.aim.forceManual = false;
        if (state.firstPerson.active) {
          exitFirstPerson();
        }
        try {
          canvasWrap.releasePointerCapture(e.pointerId);
        } catch { }
        updateHud();
      }

      const canvasWrap = document.getElementById("canvasWrap");
      canvasWrap.addEventListener("pointerdown", onPointerDown, { passive: true });
      canvasWrap.addEventListener("pointermove", onPointerMove, { passive: true });
      canvasWrap.addEventListener("pointerup", onPointerUp, { passive: true });
      canvasWrap.addEventListener("pointercancel", onPointerUp, { passive: true });

      // å…¼å®¹æ€§å…œåº•ï¼šéƒ¨åˆ†è®¾å¤‡ pointer äº‹ä»¶ä¸ç¨³å®šæ—¶ï¼Œç”¨ touch äº‹ä»¶è¡¥ä¸€å±‚
      // æ³¨æ„ï¼šåªåœ¨æ²¡æœ‰ PointerEvent çš„ç¯å¢ƒå¯ç”¨ï¼Œé¿å…é‡å¤è§¦å‘ã€‚
      if (!window.PointerEvent) {
        let touchActive = false;
        const touchId = { v: null };

        const touchDown = (e) => {
          if (!canShoot()) return;
          if (touchActive) return;
          touchActive = true;
          touchId.v = 1;
          onPointerDown({ ...e, pointerId: 1, clientX: getClientPointFromEvent(e).x, clientY: getClientPointFromEvent(e).y });
        };
        const touchMove = (e) => {
          if (!touchActive) return;
          onPointerMove({ ...e, pointerId: 1, clientX: getClientPointFromEvent(e).x, clientY: getClientPointFromEvent(e).y });
        };
        const touchUp = (e) => {
          if (!touchActive) return;
          touchActive = false;
          onPointerUp({ ...e, pointerId: 1, clientX: getClientPointFromEvent(e).x, clientY: getClientPointFromEvent(e).y });
        };

        canvasWrap.addEventListener("touchstart", touchDown, { passive: true });
        canvasWrap.addEventListener("touchmove", touchMove, { passive: true });
        canvasWrap.addEventListener("touchend", touchUp, { passive: true });
        canvasWrap.addEventListener("touchcancel", touchUp, { passive: true });
      }

      // ====== æŒ‰é’® ======
      el.btnStart.addEventListener("click", () => {
        // é¦–æ¬¡ï¼šå…ˆçœ‹å‰§æƒ…åºç« 
        if (state.mode === "boot") {
          state.chapterIndex = 0;
          openStory(CAMPAIGN[0].pre);
          return;
        }
        // match/result ä¸‹ï¼šå¼€å§‹/ç»§ç»­
        if (state.mode === "story") return;
        openStory(CAMPAIGN[state.chapterIndex].pre);
      });

      el.btnRestart.addEventListener("click", () => {
        if (state.mode === "story") return;
        startMatch();
      });

      el.btnStory.addEventListener("click", () => {
        const ch = CAMPAIGN[state.chapterIndex];
        openStory(ch.pre);
      });

      el.btnNext.addEventListener("click", () => {
        const total = state.storyQueue.length || 1;
        const idx = state.storyPos;
        if (idx >= total - 1) {
          // ç»“æŸå¯¹è¯
          showOverlay(false);
          const after = state._afterStory;
          state._afterStory = null;
          if (after === "advance") {
            toNextChapterOrFreeplay();
            return;
          }
          if (after === "retry") {
            startMatch();
            return;
          }
          // æ™®é€šé¢„å‰§æƒ…ï¼šå¼€å§‹æ¯”èµ›
          startMatch();
          return;
        }
        state.storyPos += 1;
        renderStoryStep();
      });

      el.btnSkip.addEventListener("click", () => {
        // è·³åˆ°æœ€åä¸€å¥
        state.storyPos = Math.max(0, (state.storyQueue.length || 1) - 1);
        renderStoryStep();
      });

      // ====== å¯åŠ¨ ======
      function boot() {
        state.mode = "boot";
        resetMatch();
        updateHud();
        // é»˜è®¤æ‰“å¼€åºç« 
        openStory(CAMPAIGN[0].pre);
      }

      boot();
      requestAnimationFrame(tick);
    })();
  </script>
</body>

</html>
