<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>社畜无双 - Corporate Slave Musou</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f0f4f8;
            /* Office Wall Color */
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70px;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            box-sizing: border-box;
            background: linear-gradient(180deg, #fff4d6, #f2e1bb);
            border-bottom: 3px solid #1b1b1b;
            box-shadow: 0 4px 0 #000;
            font-family: 'Smiley Sans', 'ZCOOL KuaiLe', 'ZCOOL QingKe HuangYou', 'STHeiti', 'Microsoft YaHei', sans-serif;
        }

        #ui-layer::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: repeating-linear-gradient(135deg, rgba(0, 0, 0, 0.06) 0, rgba(0, 0, 0, 0.06) 6px, transparent 6px, transparent 12px);
            opacity: 0.35;
            pointer-events: none;
        }

        #ui-layer > * {
            position: relative;
            z-index: 1;
        }

        .hud-card {
            min-width: 96px;
            padding: 6px 10px;
            border: 2px solid #1b1b1b;
            border-radius: 10px;
            box-shadow: 2px 2px 0px #000;
            text-align: center;
            background: #ffe9a8;
        }

        .hud-label {
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 1px;
            color: #6b4e00;
        }

        #kpi-value {
            font-size: 18px;
            font-weight: bold;
            color: #1f1f1f;
        }

        #info-card {
            background: #e0f2d9;
        }

        #info-card .hud-label {
            color: #2c6a2c;
        }

        #next-exp {
            font-size: 14px;
            font-weight: bold;
            color: #1f1f1f;
        }

        #exp-section {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            height: 100%;
        }

        #exp-track {
            position: relative;
            width: 100%;
            max-width: 520px;
            height: 14px;
            background: #242424;
            border: 2px solid #000;
            border-radius: 999px;
            overflow: hidden;
            box-shadow: inset 0 2px 0 rgba(255, 255, 255, 0.2);
        }

        #exp-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #f6d365, #fda085);
            z-index: 1;
        }

        #exp-text {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0px #000;
            z-index: 2;
        }

        #level-pill {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 12px;
            border: 2px solid #fff;
            border-radius: 12px;
            box-shadow: 2px 2px 0px #000;
            z-index: 3;
        }

        #pause-btn {
            pointer-events: auto;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid #000;
            background: #ffd166;
            color: #1f1f1f;
            border-radius: 10px;
            box-shadow: 2px 2px 0px #000;
            cursor: pointer;
        }

        #pause-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0px #000;
        }

        #start-overlay,
        #game-over-overlay,
        #level-up-overlay,
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 60px;
            margin: 0 0 20px 0;
            color: #ffcc00;
            text-shadow: 4px 4px 0px #000;
            text-align: center;
            transform: rotate(-2deg);
        }

        p {
            font-size: 20px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            background: #ff4757;
            color: white;
            border: 4px solid #000;
            padding: 15px 40px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 30px;
            transition: transform 0.1s;
            box-shadow: 6px 6px 0px #000;
        }

        .btn:active {
            transform: translate(4px, 4px);
            box-shadow: 2px 2px 0px #000;
        }

        .hidden {
            display: none !important;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            width: 90%;
            max-width: 900px;
            margin-top: 30px;
        }

        .upgrade-card {
            background: #fff9db;
            border: 4px solid #000;
            box-shadow: 6px 6px 0px #000;
            padding: 18px;
            text-align: left;
            cursor: pointer;
            transition: transform 0.1s;
            pointer-events: auto;
        }

        .upgrade-card:active {
            transform: translate(4px, 4px);
            box-shadow: 2px 2px 0px #000;
        }

        .upgrade-title {
            font-size: 24px;
            font-weight: bold;
            color: #222;
            margin-bottom: 8px;
        }

        .upgrade-desc {
            font-size: 16px;
            color: #333;
            line-height: 1.4;
        }

        /* Mobile controls hint */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(0, 0, 0, 0.5);
            font-size: 14px;
        }

        #boss-warning {
            position: absolute;
            top: 70px;
            left: 0;
            width: 100%;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: repeating-linear-gradient(135deg, #ff4757 0, #ff4757 12px, #ff6b6b 12px, #ff6b6b 24px);
            color: #fff;
            border-top: 3px solid #111;
            border-bottom: 3px solid #111;
            text-shadow: 2px 2px 0px #000;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 4px;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }

        #boss-warning.show {
            animation: bossWarn 1.4s ease forwards;
        }

        #boss-flash {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(255, 71, 87, 0.35), rgba(255, 71, 87, 0.15) 45%, rgba(255, 71, 87, 0) 70%);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
        }

        #boss-flash.show {
            animation: bossFlash 1.2s ease forwards;
        }

        @keyframes bossWarn {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            25% { opacity: 1; transform: translateY(0); }
            40% { opacity: 0.7; transform: translateY(0); }
            55% { opacity: 1; transform: translateY(0); }
            70% { opacity: 0.7; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(0); }
        }

        @keyframes bossFlash {
            0% { opacity: 0; }
            20% { opacity: 0.5; }
            50% { opacity: 0.25; }
            100% { opacity: 0; }
        }

        @keyframes alarmShake {
            0% { transform: translate(0, 0); }
            20% { transform: translate(-2px, 1px); }
            40% { transform: translate(2px, -1px); }
            60% { transform: translate(-1px, -2px); }
            80% { transform: translate(2px, 2px); }
            100% { transform: translate(0, 0); }
        }

        body.alarm-shake {
            animation: alarmShake 0.6s linear 1;
        }

        #joystick-wrap {
            position: absolute;
            left: 16px;
            bottom: 20px;
            width: 120px;
            height: 120px;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.12s ease, transform 0.12s ease;
        }

        #joystick-wrap.active {
            opacity: 1;
            transform: scale(1);
        }

        #joystick-base {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid #000;
            background: rgba(255, 255, 255, 0.6);
            box-shadow: 4px 4px 0px #000;
            pointer-events: auto;
        }

        #joystick-stick {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #111;
            border: 2px solid #fff;
            box-shadow: 2px 2px 0px #000;
            transform: translate(-50%, -50%);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 40px;
            }

            .upgrade-title {
                font-size: 20px;
            }

            #ui-layer {
                height: 58px;
                padding: 6px 10px;
                gap: 8px;
            }

            .hud-card {
                min-width: 80px;
                padding: 4px 8px;
            }

            #kpi-value {
                font-size: 16px;
            }

            #next-exp {
                font-size: 12px;
            }

            #exp-track {
                height: 12px;
            }

            #exp-text {
                font-size: 9px;
            }

            #level-pill {
                font-size: 10px;
                padding: 1px 8px;
            }

            #pause-btn {
                padding: 4px 8px;
                font-size: 12px;
            }

            #mobile-controls {
                display: block;
            }

            #boss-warning {
                top: 58px;
                height: 32px;
                font-size: 16px;
            }

            #joystick-wrap {
                left: 10px;
                bottom: 16px;
                width: 110px;
                height: 110px;
            }

            #joystick-base {
                width: 110px;
                height: 110px;
            }

            #joystick-stick {
                width: 44px;
                height: 44px;
            }
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="kpi-card" class="hud-card">
            <div class="hud-label">KPI</div>
            <div id="kpi-value">0</div>
        </div>
        <div id="exp-section">
            <div id="exp-track">
                <div id="exp-fill"></div>
                <div id="exp-text">0/0</div>
            </div>
            <div id="level-pill">LV. 1</div>
        </div>
        <div id="info-card" class="hud-card">
            <div class="hud-label">晋升</div>
            <div id="next-exp">还需 0</div>
        </div>
        <button id="pause-btn">暂停</button>
    </div>

    <div id="boss-warning">BOSS 入场</div>
    <div id="boss-flash"></div>

    <div id="start-overlay">
        <h1>社畜无双</h1>
        <p>在无尽的格子间里，用键盘和咖啡杀出一条血路！<br>
            WSAD / 触摸移动，鼠标 / 自动瞄准攻击。<br>
            击败同事，躲避PPT，小心周一例会！</p>
        <button id="start-btn" class="btn">办理入职 (点击开始)</button>
    </div>

    <div id="game-over-overlay" class="hidden">
        <h1 style="color: #ff4757;">被优化了</h1>
        <p id="final-score">KPI 达成率: 0</p>
        <p>HR: "很遗憾，你未能通过试用期。"</p>
        <button id="restart-btn" class="btn">投递简历 (重新开始)</button>
    </div>

    <div id="level-up-overlay" class="hidden">
        <h1>升职加薪</h1>
        <p>请选择一项强化</p>
        <p style="font-size: 16px; opacity: 0.8;">可按 1 / 2 / 3 快速选择</p>
        <div id="upgrade-options" class="upgrade-grid"></div>
    </div>

    <div id="pause-overlay" class="hidden">
        <h1>玩法说明</h1>
        <p>
            WSAD / 方向键 / 拖动摇杆移动<br>
            鼠标 / 自动瞄准攻击，点击任意位置拖动移动<br>
            击败同事，躲避PPT，升级选择强化<br>
            空格 或 点击暂停按钮 可关闭此面板
        </p>
        <button id="resume-btn" class="btn">继续奋斗</button>
    </div>

    <div id="mobile-controls">拖动屏幕移动 • 自动攻击</div>
    <div id="joystick-wrap">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>

    <script>
        /**
         * AUDIO SYSTEM
         * Synthesizes sound effects using Web Audio API to mimic office sounds.
         */
        const AudioSys = (() => {
            let ctx = null;
            let masterGain = null;

            function init() {
                if (!ctx) {
                    ctx = new (window.AudioContext || window.webkitAudioContext)();
                    masterGain = ctx.createGain();
                    masterGain.gain.value = 0.4;
                    masterGain.connect(ctx.destination);
                }
                if (ctx.state === 'suspended') ctx.resume();
            }

            // Generate White Noise Buffer
            let noiseBuffer = null;
            function getNoiseBuffer() {
                if (!noiseBuffer && ctx) {
                    const bufferSize = ctx.sampleRate * 2; // 2 seconds
                    noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                }
                return noiseBuffer;
            }

            function playSound(type) {
                if (!ctx) return;

                const t = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                switch (type) {
                    case 'shoot': // Keyboard click (high pitch click)
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(800, t);
                        osc.frequency.exponentialRampToValueAtTime(100, t + 0.05);
                        gain.gain.setValueAtTime(0.3, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start(t);
                        osc.stop(t + 0.05);
                        break;

                    case 'hit': // Thud (soft body impact)
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
                        gain.gain.setValueAtTime(0.5, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start(t);
                        osc.stop(t + 0.2);
                        break;

                    case 'paper': // Whoosh (Paper storm)
                        const noise = ctx.createBufferSource();
                        noise.buffer = getNoiseBuffer();
                        const filter = ctx.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.Q.value = 1;
                        filter.frequency.setValueAtTime(800, t);
                        filter.frequency.linearRampToValueAtTime(2000, t + 0.2);

                        gain.gain.setValueAtTime(0.4, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.2);

                        noise.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);
                        noise.start(t);
                        noise.stop(t + 0.2);
                        break;

                    case 'coin': // KPI pickup
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(1200, t);
                        osc.frequency.setValueAtTime(1600, t + 0.1);
                        gain.gain.setValueAtTime(0.3, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.2);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start(t);
                        osc.stop(t + 0.2);
                        break;

                    case 'laser': // PPT Laser
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(800, t);
                        osc.frequency.linearRampToValueAtTime(200, t + 0.5);
                        gain.gain.setValueAtTime(0.2, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.5);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start(t);
                        osc.stop(t + 0.5);
                        break;

                    case 'excel': // Heavy impact
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(50, t);
                        osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                        gain.gain.setValueAtTime(0.8, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.start(t);
                        osc.stop(t + 0.5);
                        break;
                }
            }

            return { init, playSound };
        })();

        /**
         * GAME ENGINE & UTILS
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        let isMobile = ('ontouchstart' in window);

        function resize() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Input State
        const keys = {};
        const mouse = { x: screenWidth / 2, y: screenHeight / 2, down: false };
        const joystick = { active: false, dx: 0, dy: 0, originX: 0, originY: 0 };
        let joystickPointerId = null;
        let joystickMode = 'fixed';

        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);

        const joystickWrap = document.getElementById('joystick-wrap');
        const joystickBase = document.getElementById('joystick-base');
        const joystickStick = document.getElementById('joystick-stick');

        function setJoystick(dx, dy, maxDist) {
            const len = Math.hypot(dx, dy);
            let nx = dx;
            let ny = dy;
            if (len > maxDist) {
                const scale = maxDist / len;
                nx *= scale;
                ny *= scale;
            }
            joystick.dx = nx;
            joystick.dy = ny;
            joystickStick.style.transform = `translate(-50%, -50%) translate(${nx}px, ${ny}px)`;
        }

        function resetJoystick() {
            joystick.active = false;
            joystick.dx = 0;
            joystick.dy = 0;
            joystickPointerId = null;
            joystickMode = 'fixed';
            joystickStick.style.transform = 'translate(-50%, -50%)';
            joystickWrap.style.left = '';
            joystickWrap.style.top = '';
            joystickWrap.style.bottom = '';
            joystickWrap.classList.remove('active');
        }

        function handleJoystickMove(clientX, clientY) {
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            joystick.originX = centerX;
            joystick.originY = centerY;
            setJoystick(clientX - centerX, clientY - centerY, rect.width * 0.35);
        }

        function handleFreeMove(clientX, clientY) {
            const rect = joystickBase.getBoundingClientRect();
            const maxDist = rect.width * 0.35;
            setJoystick(clientX - joystick.originX, clientY - joystick.originY, maxDist);
        }

        function startJoystick(pointerId, clientX, clientY, mode) {
            joystick.active = true;
            joystickPointerId = pointerId;
            joystickMode = mode;
            joystickWrap.classList.add('active');
            if (mode === 'free') {
                const rect = joystickBase.getBoundingClientRect();
                joystickWrap.style.left = `${clientX - rect.width / 2}px`;
                joystickWrap.style.top = `${clientY - rect.height / 2}px`;
                joystickWrap.style.bottom = 'auto';
                joystick.originX = clientX;
                joystick.originY = clientY;
                setJoystick(0, 0, rect.width * 0.35);
            } else {
                handleJoystickMove(clientX, clientY);
            }
        }

        joystickBase.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            startJoystick(e.pointerId, e.clientX, e.clientY, 'fixed');
            joystickBase.setPointerCapture(joystickPointerId);
        });

        joystickBase.addEventListener('pointermove', (e) => {
            if (!joystick.active || joystickPointerId !== e.pointerId) return;
            e.preventDefault();
            if (joystickMode === 'free') {
                handleFreeMove(e.clientX, e.clientY);
            } else {
                handleJoystickMove(e.clientX, e.clientY);
            }
        });

        joystickBase.addEventListener('pointerup', (e) => {
            if (joystickPointerId !== e.pointerId) return;
            if (joystickBase.hasPointerCapture(joystickPointerId)) {
                joystickBase.releasePointerCapture(joystickPointerId);
            }
            resetJoystick();
        });

        joystickBase.addEventListener('pointercancel', (e) => {
            if (joystickPointerId !== e.pointerId) return;
            if (joystickBase.hasPointerCapture(joystickPointerId)) {
                joystickBase.releasePointerCapture(joystickPointerId);
            }
            resetJoystick();
        });

        window.addEventListener('pointerdown', (e) => {
            if (gameData.state !== 'playing') return;
            if (joystick.active) return;
            if (e.button !== undefined && e.button !== 0) return;
            if (e.target.closest && e.target.closest('#joystick-base')) return;
            if (e.target.closest && (e.target.closest('#ui-layer') || e.target.closest('#start-overlay') || e.target.closest('#level-up-overlay') || e.target.closest('#game-over-overlay') || e.target.closest('#pause-overlay'))) return;
            startJoystick(e.pointerId, e.clientX, e.clientY, 'free');
        });

        window.addEventListener('pointermove', (e) => {
            if (!joystick.active || joystickPointerId !== e.pointerId) return;
            if (joystickMode === 'free') {
                handleFreeMove(e.clientX, e.clientY);
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (!joystick.active || joystickPointerId !== e.pointerId) return;
            resetJoystick();
        });

        window.addEventListener('pointercancel', (e) => {
            if (!joystick.active || joystickPointerId !== e.pointerId) return;
            resetJoystick();
        });

        window.addEventListener('blur', resetJoystick);

        // Math Utils
        const rand = (min, max) => Math.random() * (max - min) + min;
        function hash2(x, y) {
            let h = x * 374761393 + y * 668265263;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h ^ (h >> 16)) >>> 0;
        }
        function randFromCoord(x, y, seed = 0) {
            return hash2(x + seed * 31, y - seed * 17) / 4294967295;
        }
        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const lerp = (a, b, t) => a + (b - a) * t;

        // Camera (world -> screen)
        const camera = { x: 0, y: 0 };
        function updateCamera() {
            camera.x = player.x - screenWidth / 2;
            camera.y = player.y - screenHeight / 2;
        }
        function screenToWorld(x, y) {
            return { x: x + camera.x, y: y + camera.y };
        }

        /**
         * JELLY PHYSICS SYSTEM
         * Implements a soft-body blob using a central point and radial vertices.
         */
        class JellyBody {
            constructor(x, y, radius, color, points = 8) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.points = [];
                this.angleStep = (Math.PI * 2) / points;

                // Spring properties
                this.stiffness = 0.15;
                this.damping = 0.8;

                for (let i = 0; i < points; i++) {
                    const angle = i * this.angleStep;
                    this.points.push({
                        x: Math.cos(angle) * radius, // Relative pos
                        y: Math.sin(angle) * radius,
                        ox: Math.cos(angle) * radius, // Original rest pos
                        oy: Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0
                    });
                }
            }

            update(dt) {
                // Soft body simulation
                for (let p of this.points) {
                    // Hooke's law: Force towards original position
                    const ax = (p.ox - p.x) * this.stiffness;
                    const ay = (p.oy - p.y) * this.stiffness;

                    p.vx += ax;
                    p.vy += ay;
                    p.vx *= this.damping;
                    p.vy *= this.damping;

                    p.x += p.vx;
                    p.y += p.vy;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';

                ctx.beginPath();
                // Draw curve through points
                const first = this.points[0];
                // Start from midpoint between last and first to make it smooth loop
                const last = this.points[this.points.length - 1];
                let midX = (this.x + last.x + this.x + first.x) / 2;
                let midY = (this.y + last.y + this.y + first.y) / 2;

                ctx.moveTo(midX, midY);

                for (let i = 0; i < this.points.length; i++) {
                    const p = this.points[i];
                    const nextIndex = (i + 1) % this.points.length;
                    const nextP = this.points[nextIndex];
                    const nextMidX = (this.x + p.x + this.x + nextP.x) / 2;
                    const nextMidY = (this.y + p.y + this.y + nextP.y) / 2;

                    ctx.quadraticCurveTo(this.x + p.x, this.y + p.y, nextMidX, nextMidY);
                }

                ctx.fill();
                ctx.stroke();
            }

            deform(dx, dy, force) {
                // Apply force to points roughly in direction of movement
                // Or random noise
                for (let p of this.points) {
                    p.vx -= dx * force * rand(0.5, 1.5);
                    p.vy -= dy * force * rand(0.5, 1.5);
                }
            }

            hit(angle, force) {
                // Push points inward based on hit angle
                for (let i = 0; i < this.points.length; i++) {
                    const pAngle = i * this.angleStep;
                    const diff = Math.atan2(Math.sin(pAngle - angle), Math.cos(pAngle - angle));
                    if (Math.abs(diff) < 1.5) {
                        const impact = Math.cos(diff) * force;
                        this.points[i].vx -= Math.cos(pAngle) * impact;
                        this.points[i].vy -= Math.sin(pAngle) * impact;
                    }
                }
            }
        }

        /**
         * GAME OBJECTS
         */

        // Particles for Juice
        const particles = [];
        class Particle {
            constructor(x, y, color, size, speed) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                const angle = rand(0, Math.PI * 2);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = rand(0.02, 0.05);
                this.gravity = 0.2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity; // Gravity
                this.life -= this.decay;
                this.vx *= 0.9;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        function spawnParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, rand(3, 8), rand(2, 8)));
            }
        }

        // Projectiles
        const projectiles = [];
        class Projectile {
            constructor(x, y, tx, ty, type, options = {}) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.owner = options.owner || 'player';
                const angle = Math.atan2(ty - y, tx - x);
                const baseSpeed = options.speed !== undefined ? options.speed : 10 * player.projectileSpeed;
                this.vx = Math.cos(angle) * baseSpeed;
                this.vy = Math.sin(angle) * baseSpeed;
                this.life = 100;
                const sizeScale = options.size !== undefined ? options.size : player.projectileSize;
                this.radius = 10 * sizeScale;
                this.damage = options.damage !== undefined ? options.damage : (this.owner === 'player' ? player.damageMultiplier : 1);
                if (options.pierce !== undefined) {
                    this.pierce = options.pierce;
                } else if (this.type === 'paper') {
                    this.pierce = 999;
                } else if (this.owner === 'player') {
                    this.pierce = player.keyboardPierce;
                } else {
                    this.pierce = 0;
                }

                // Visual
                this.char = 'A';
                if (type === 'keyboard') {
                    const chars = ['K', 'P', 'I', 'Q', 'W', 'E', 'R', 'T', 'Y'];
                    this.char = chars[Math.floor(Math.random() * chars.length)];
                }
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.type === 'keyboard') {
                    ctx.fillStyle = '#333';
                    const size = 20 * (this.radius / 10);
                    ctx.fillRect(-size / 2, -size / 2, size, size);
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${Math.max(10, size * 0.7)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.char, 0, 1);
                } else if (this.type === 'paper') {
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.rotate(this.life * 0.2);
                    const w = 16 * (this.radius / 10);
                    const h = 24 * (this.radius / 10);
                    ctx.fillRect(-w / 2, -h / 2, w, h);
                    ctx.strokeRect(-w / 2, -h / 2, w, h);
                } else if (this.type === 'enemy_hr') {
                    ctx.fillStyle = '#ff4757';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8 * (this.radius / 10), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // Pickups
        const drops = [];
        class Drop {
            constructor(x, y, expValue = 10) {
                this.x = x;
                this.y = y;
                this.expValue = expValue;
                const sizeScale = Math.min(3.2, 0.7 + Math.pow(this.expValue / 12, 0.38));
                this.radius = 7 * sizeScale;
                this.bob = rand(0, Math.PI * 2);
            }
            update() {
                this.bob += 0.1;
            }
            draw(ctx) {
                const oy = Math.sin(this.bob) * 5;
                ctx.fillStyle = '#ffd32a';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y + oy, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.font = `bold ${Math.max(10, this.radius * 1.1)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('¥', this.x, this.y + oy + 1);
            }
        }

        // Coffee Zones (slow + damage over time)
        const coffeeZones = [];
        class CoffeeZone {
            constructor(x, y, level) {
                this.x = x;
                this.y = y;
                this.level = level;
                this.radius = 70 + level * 15 + player.coffeeRadiusBonus;
                this.life = 240 + level * 60 + player.coffeeDurationBonus;
                this.tick = 0;
                this.slow = Math.max(0.35, 0.75 - level * 0.1);
            }
            update() {
                this.life--;
                this.tick++;
                if (this.tick % 20 === 0) {
                    for (const e of enemies) {
                        if (!e.markedForDeletion && dist(this.x, this.y, e.x, e.y) < this.radius + e.radius) {
                            damageEnemy(e, 1, null, true);
                        }
                    }
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = '#6ab04c';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#2f3640';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Player
        const player = {
            x: 0, y: 0,
            body: null,
            speed: 5,
            hp: 100,
            maxHp: 100,
            level: 1,
            exp: 0,
            expToNext: 100,
            pendingLevelUps: 0,
            kpi: 0, // Score
            magnetRange: 100,
            regen: 0,
            expGain: 1,
            damageMultiplier: 1,
            projectileSpeed: 1,
            projectileSize: 1,
            keyboardExtraShots: 0,
            printerExtraCount: 0,
            critChance: 0,
            critMultiplier: 2,
            keyboardPierce: 0,
            chairCount: 0,
            chairRadius: 70,
            chairSpeed: 0.05,
            chairDamage: 1,
            chairAngle: 0,
            killHeal: 0,
            coffeeRadiusBonus: 0,
            coffeeDurationBonus: 0,
            weapons: {
                keyboard: { level: 1, timer: 0, cooldown: 15 },
                printer: { level: 0, timer: 0, cooldown: 80 },
                coffee: { level: 0, timer: 0, cooldown: 180 }
            },

            init() {
                this.x = 0;
                this.y = 0;
                this.body = new JellyBody(this.x, this.y, 25, '#0fbcf9', 10);
                this.hp = 100;
                this.maxHp = 100;
                this.speed = 5;
                this.kpi = 0;
                this.level = 1;
                this.exp = 0;
                this.expToNext = 100;
                this.pendingLevelUps = 0;
                this.magnetRange = 100;
                this.regen = 0;
                this.expGain = 1;
                this.damageMultiplier = 1;
                this.projectileSpeed = 1;
                this.projectileSize = 1;
                this.keyboardExtraShots = 0;
                this.printerExtraCount = 0;
                this.critChance = 0;
                this.critMultiplier = 2;
                this.keyboardPierce = 0;
                this.chairCount = 0;
                this.chairRadius = 70;
                this.chairSpeed = 0.05;
                this.chairDamage = 1;
                this.chairAngle = 0;
                this.killHeal = 0;
                this.coffeeRadiusBonus = 0;
                this.coffeeDurationBonus = 0;
                // Reset weapons
                this.weapons.keyboard.level = 1;
                this.weapons.printer.level = 0;
                this.weapons.coffee.level = 0;
                this.weapons.keyboard.cooldown = 15;
                this.weapons.printer.cooldown = 80;
                this.weapons.coffee.cooldown = 180;
            },

            update() {
                let dx = 0;
                let dy = 0;

                // Keyboard Input
                if (keys['w'] || keys['ArrowUp']) dy = -1;
                if (keys['s'] || keys['ArrowDown']) dy = 1;
                if (keys['a'] || keys['ArrowLeft']) dx = -1;
                if (keys['d'] || keys['ArrowRight']) dx = 1;

                // Touch Input
                if (joystick.active) {
                    const len = Math.hypot(joystick.dx, joystick.dy);
                    if (len > 10) {
                        dx = joystick.dx / len;
                        dy = joystick.dy / len;
                    }
                }

                // Normalize
                if (dx !== 0 || dy !== 0) {
                    const len = Math.hypot(dx, dy);
                    dx /= len;
                    dy /= len;
                    this.x += dx * this.speed;
                    this.y += dy * this.speed;

                    // Wobble
                    this.body.deform(dx, dy, 1);
                }

                // Sync visual body
                this.body.x = this.x;
                this.body.y = this.y;
                this.body.update();

                updateCamera();
                if (this.chairCount > 0) {
                    this.chairAngle += this.chairSpeed;
                }

                // Auto Attack
                this.handleWeapons();

                // Regen
                if (this.regen > 0 && this.hp < this.maxHp) {
                    this.hp = Math.min(this.maxHp, this.hp + this.regen / 60);
                }
            },

            handleWeapons() {
                // Find nearest enemy
                let target = null;
                let minDist = 500; // range

                for (const e of enemies) {
                    const d = dist(this.x, this.y, e.x, e.y);
                    if (d < minDist) {
                        minDist = d;
                        target = e;
                    }
                }

                // Weapon: Keyboard (Basic Shooter)
                const kb = this.weapons.keyboard;
                if (kb.level > 0) {
                    kb.timer++;
                    if (kb.timer >= kb.cooldown) {
                        kb.timer = 0;
                        let tx = target ? target.x : this.x + rand(-120, 120);
                        let ty = target ? target.y : this.y + rand(-120, 120);
                        if (!target && (mouse.x !== this.x)) {
                            const worldMouse = screenToWorld(mouse.x, mouse.y);
                            tx = worldMouse.x;
                            ty = worldMouse.y;
                        }

                        projectiles.push(new Projectile(this.x, this.y, tx, ty, 'keyboard'));
                        AudioSys.playSound('shoot');

                        if (this.keyboardExtraShots > 0) {
                            const baseAngle = Math.atan2(ty - this.y, tx - this.x);
                            const spread = Math.PI / 14;
                            const dist = 160;
                            for (let i = 1; i <= this.keyboardExtraShots; i++) {
                                const dir = (i % 2 === 1) ? 1 : -1;
                                const step = Math.ceil(i / 2);
                                const angle = baseAngle + dir * step * spread;
                                const sx = this.x + Math.cos(angle) * dist;
                                const sy = this.y + Math.sin(angle) * dist;
                                projectiles.push(new Projectile(this.x, this.y, sx, sy, 'keyboard'));
                            }
                        }

                        if (kb.level >= 2) {
                            // Multishot
                            setTimeout(() => projectiles.push(new Projectile(this.x, this.y, tx + 20, ty + 20, 'keyboard')), 80);
                        }
                        if (kb.level >= 3) {
                            setTimeout(() => projectiles.push(new Projectile(this.x, this.y, tx - 20, ty - 10, 'keyboard')), 120);
                        }
                    }
                }

                // Weapon: Printer (AOE Storm)
                const pr = this.weapons.printer;
                if (pr.level > 0) {
                    pr.timer++;
                    if (pr.timer >= pr.cooldown) {
                        pr.timer = 0;
                        let count = pr.level === 1 ? 8 : pr.level === 2 ? 12 : 16;
                        count += this.printerExtraCount;
                        for (let i = 0; i < count; i++) {
                            const angle = (Math.PI * 2 / count) * i;
                            const tx = this.x + Math.cos(angle) * 100;
                            const ty = this.y + Math.sin(angle) * 100;
                            projectiles.push(new Projectile(this.x, this.y, tx, ty, 'paper'));
                        }
                        AudioSys.playSound('paper');
                    }
                }

                // Weapon: Coffee (Slow + DOT)
                const cf = this.weapons.coffee;
                if (cf.level > 0) {
                    cf.timer++;
                    if (cf.timer >= cf.cooldown) {
                        cf.timer = 0;
                        coffeeZones.push(new CoffeeZone(this.x, this.y, cf.level));
                        AudioSys.playSound('paper');
                    }
                }
            },

            draw(ctx) {
                this.body.draw(ctx);
                // Vitality bar (above head)
                const barWidth = 60;
                const barHeight = 8;
                const barOffset = this.body.radius + 18;
                const barX = this.x - barWidth / 2;
                const barY = this.y - barOffset;
                const ratio = Math.max(0, Math.min(1, this.hp / this.maxHp));
                ctx.save();
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(barX, barY, barWidth * ratio, barHeight);
                ctx.strokeStyle = '#1f1f1f';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                ctx.restore();
                // Face (Glasses & Tie)
                ctx.fillStyle = '#000';
                // Glasses
                ctx.fillRect(this.x - 12, this.y - 5, 8, 4);
                ctx.fillRect(this.x + 4, this.y - 5, 8, 4);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - 4, this.y - 3);
                ctx.lineTo(this.x + 4, this.y - 3);
                ctx.stroke();
                // Tie
                ctx.fillStyle = '#ff4757';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 5);
                ctx.lineTo(this.x - 4, this.y + 20);
                ctx.lineTo(this.x + 4, this.y + 20);
                ctx.fill();
            }
        };

        function getChairPositions() {
            const positions = [];
            if (player.chairCount <= 0) return positions;
            const step = (Math.PI * 2) / player.chairCount;
            for (let i = 0; i < player.chairCount; i++) {
                const angle = player.chairAngle + step * i;
                positions.push({
                    x: player.x + Math.cos(angle) * player.chairRadius,
                    y: player.y + Math.sin(angle) * player.chairRadius
                });
            }
            return positions;
        }

        function drawChairs(ctx) {
            const chairs = getChairPositions();
            if (chairs.length === 0) return;
            for (const c of chairs) {
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate(player.chairAngle * 2);
                ctx.fillStyle = '#8d6e63';
                ctx.strokeStyle = '#2f2f2f';
                ctx.lineWidth = 2;
                ctx.fillRect(-10, -6, 20, 12);
                ctx.strokeRect(-10, -6, 20, 12);
                ctx.fillRect(-6, 6, 12, 10);
                ctx.strokeRect(-6, 6, 12, 10);
                ctx.restore();
            }
        }

        // Enemies
        const enemies = [];
        function countEnemiesByType(type) {
            let count = 0;
            for (const enemy of enemies) {
                if (enemy.type === type) count++;
            }
            return count;
        }
        function getEnemyPower() {
            const seconds = gameData.waveTimer / 60;
            const power = Math.min(4.5, 1 + seconds * 0.012);
            const hpPower = Math.min(7, 1 + seconds * 0.02);
            const minionPower = Math.min(3, 1 + seconds * 0.006);
            const minionHpPower = Math.min(4.5, 1 + seconds * 0.01);
            return { power, hpPower, minionPower, minionHpPower };
        }
        const eliteNamePool = [
            '摸鱼王中王·精英',
            '领导画饼师·精英',
            '临时会议怪·精英',
            'KPI拉满侠·精英',
            '不躺不卷·精英',
            '周报卷王·精英',
            '996驱动员·精英'
        ];
        const bossNamePool = [
            'PPT主宰者·BOSS',
            'Excel吞噬者·BOSS',
            '终极画饼王·BOSS',
            '内卷大魔王·BOSS',
            '摸鱼终结者·BOSS',
            '需求变更王·BOSS'
        ];
        function pickName(pool) {
            return pool[Math.floor(Math.random() * pool.length)];
        }
        class Enemy {
            constructor(type) {
                const spawnDistance = Math.max(screenWidth, screenHeight) * 0.8 + 120;
                const spawnAngle = rand(0, Math.PI * 2);
                this.x = player.x + Math.cos(spawnAngle) * spawnDistance;
                this.y = player.y + Math.sin(spawnAngle) * spawnDistance;

                this.type = type;
                this.markedForDeletion = false;
                this.chairHitCooldown = 0;
                this.name = '';
                const powerData = getEnemyPower();
                this.power = powerData.power;
                this.hpPower = powerData.hpPower;
                const speedScale = 1 + (this.power - 1) * 0.5;

                if (type === 'colleague') {
                    const minionSpeedScale = 1 + (powerData.minionPower - 1) * 0.5;
                    this.speed = rand(1, 2) * minionSpeedScale;
                    this.hp = Math.ceil(3 * powerData.minionHpPower);
                    this.maxHp = this.hp;
                    this.radius = 20;
                    this.color = '#bdc3c7'; // Grey
                    this.score = 10;
                    this.contactDamage = Math.max(1, Math.round(2 * powerData.minionPower));
                    this.name = '';
                } else if (type === 'manager') {
                    this.speed = 2.5 * speedScale;
                    this.hp = Math.ceil(8 * this.hpPower);
                    this.maxHp = this.hp;
                    this.radius = 25;
                    this.color = '#e056fd'; // Purple
                    this.score = 80;
                    this.contactDamage = Math.max(2, Math.round(3 * this.power));
                    this.name = pickName(eliteNamePool);
                } else if (type === 'boss') {
                    // Boss Logic override
                    this.x = player.x;
                    this.y = player.y - (screenHeight / 2 + 200);
                    this.speed = 1 * (1 + (this.power - 1) * 0.35);
                    this.hp = Math.min(2200, Math.ceil(500 * this.hpPower));
                    this.maxHp = this.hp;
                    this.radius = 60;
                    this.color = '#2ecc71'; // Green
                    this.score = 2000;
                    this.state = 'enter';
                    this.timer = 0;
                    this.laserCd = 0;
                    this.excelCd = 0;
                    this.contactDamage = Math.max(4, Math.round(5 * this.power));
                    this.projectileDamage = Math.max(2, Math.round(2 * this.power));
                    this.name = pickName(bossNamePool);
                }

                this.body = new JellyBody(this.x, this.y, this.radius, this.color, type === 'boss' ? 16 : 8);
            }

            update() {
                // AI
                if (this.type === 'boss') {
                    this.updateBoss();
                } else {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    let slowFactor = 1;
                    for (const zone of coffeeZones) {
                        if (dist(this.x, this.y, zone.x, zone.y) < zone.radius + this.radius) {
                            slowFactor = Math.min(slowFactor, zone.slow);
                        }
                    }
                    const moveSpeed = this.speed * slowFactor;
                    this.vx = Math.cos(angle) * moveSpeed;
                    this.vy = Math.sin(angle) * moveSpeed;
                    this.x += this.vx;
                    this.y += this.vy;
                }

                // Push apart
                for (const other of enemies) {
                    if (other === this) continue;
                    const d = dist(this.x, this.y, other.x, other.y);
                    const minDist = this.radius + other.radius;
                    if (d < minDist) {
                        const pushAngle = Math.atan2(this.y - other.y, this.x - other.x);
                        const pushForce = 0.5;
                        this.x += Math.cos(pushAngle) * pushForce;
                        this.y += Math.sin(pushAngle) * pushForce;
                    }
                }

                // Jelly Update
                this.body.x = this.x;
                this.body.y = this.y;
                this.body.update();
                if (this.vx || this.vy) {
                    const vLen = Math.hypot(this.vx, this.vy) || 1;
                    this.body.deform(this.vx / vLen, this.vy / vLen, 0.5);
                }

                if (this.chairHitCooldown > 0) {
                    this.chairHitCooldown--;
                }
            }

            updateBoss() {
                this.timer++;
                if (this.laserCd > 0) this.laserCd--;
                if (this.excelCd > 0) this.excelCd--;
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const distToPlayer = dist(this.x, this.y, player.x, player.y);
                let slowFactor = 1;
                for (const zone of coffeeZones) {
                    if (dist(this.x, this.y, zone.x, zone.y) < zone.radius + this.radius) {
                        slowFactor = Math.min(slowFactor, zone.slow);
                    }
                }
                let moveScale = 1;
                if (this.state === 'charge') moveScale = 0.15;
                if (this.state === 'laser') moveScale = 0.25;
                const moveSpeed = this.speed * slowFactor * moveScale;
                const chasing = (this.state === 'idle' && (this.laserCd > 0 || this.excelCd > 0));
                const desiredDist = chasing ? 140 : 240;
                const innerDist = chasing ? 90 : 180;
                const outerDist = chasing ? 220 : 320;
                if (chasing) {
                    if (distToPlayer < innerDist) {
                        this.vx = -Math.cos(angle) * moveSpeed * 0.6;
                        this.vy = -Math.sin(angle) * moveSpeed * 0.6;
                    } else {
                        this.vx = Math.cos(angle) * moveSpeed;
                        this.vy = Math.sin(angle) * moveSpeed;
                    }
                } else {
                    if (distToPlayer > outerDist) {
                        this.vx = Math.cos(angle) * moveSpeed;
                        this.vy = Math.sin(angle) * moveSpeed;
                    } else if (distToPlayer < innerDist) {
                        this.vx = -Math.cos(angle) * moveSpeed;
                        this.vy = -Math.sin(angle) * moveSpeed;
                    } else {
                        const orbitAngle = angle + Math.PI / 2;
                        this.vx = Math.cos(orbitAngle) * moveSpeed * 0.7;
                        this.vy = Math.sin(orbitAngle) * moveSpeed * 0.7;
                    }
                }
                this.x += this.vx;
                this.y += this.vy;

                if (this.state === 'enter') {
                    this.state = 'idle';
                }

                if (this.state === 'idle') {
                    // Attack 1: PPT Laser (with cooldown)
                    if (this.laserCd <= 0) {
                        this.state = 'charge';
                        this.chargeTimer = 0;
                        this.laserCd = 300;
                    } else if (this.excelCd <= 0) {
                        // Summon Excel falling blocks
                        AudioSys.playSound('excel');
                        // Creating dummy projectiles for visual
                        for (let i = 0; i < 5; i++) {
                            const px = rand(player.x - screenWidth / 2, player.x + screenWidth / 2);
                            projectiles.push({
                                x: px,
                                y: player.y - screenHeight / 2 - 60,
                                vx: 0,
                                vy: 5,
                                type: 'excel',
                                owner: 'enemy',
                                life: 100, radius: 20,
                                draw: function (ctx) {
                                    ctx.fillStyle = '#27ae60';
                                    ctx.fillRect(this.x, this.y, 40, 30);
                                    ctx.fillStyle = '#fff';
                                    ctx.fillText('XLS', this.x + 10, this.y + 20);
                                },
                                update: function () { this.y += this.vy; this.life--; }
                            });
                        }
                        this.excelCd = 360;
                    }
                } else if (this.state === 'laser') {
                    this.laserTimer = (this.laserTimer || 0) + 1;
                    if (this.laserTimer % 10 === 0) {
                        const petalCount = 8;
                        const baseAngle = this.laserTimer * 0.12;
                        for (let i = 0; i < petalCount; i++) {
                            const angle = baseAngle + (Math.PI * 2 / petalCount) * i;
                            const tx = this.x + Math.cos(angle) * 220;
                            const ty = this.y + Math.sin(angle) * 220;
                            projectiles.push(new Projectile(this.x, this.y, tx, ty, 'enemy_hr', {
                                owner: 'enemy',
                                speed: 5.4,
                                damage: this.projectileDamage || 2,
                                size: 1
                            }));
                        }
                    }

                    if (this.laserTimer % 20 === 0) {
                        const innerCount = 5;
                        const innerAngle = -this.laserTimer * 0.1;
                        for (let i = 0; i < innerCount; i++) {
                            const angle = innerAngle + (Math.PI * 2 / innerCount) * i;
                            const tx = this.x + Math.cos(angle) * 180;
                            const ty = this.y + Math.sin(angle) * 180;
                            projectiles.push(new Projectile(this.x, this.y, tx, ty, 'enemy_hr', {
                                owner: 'enemy',
                                speed: 4.9,
                                damage: this.projectileDamage || 2,
                                size: 1
                            }));
                        }
                    }

                    if (this.laserTimer >= 140) {
                        this.state = 'idle';
                    }
                } else if (this.state === 'charge') {
                    this.chargeTimer++;
                    if (this.chargeTimer === 12) {
                        AudioSys.playSound('laser');
                        gameData.freeze = 5;
                    }
                    if (this.chargeTimer >= 30) {
                        this.state = 'laser';
                        this.laserTimer = 0;
                    }
                }
            }

            draw(ctx) {
                this.body.draw(ctx);

                // Name tag for elite/boss
                if (this.name) {
                    const nameOffset = this.type === 'boss' ? this.radius + 38 : this.radius + 18;
                    ctx.save();
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.strokeText(this.name, this.x, this.y - nameOffset);
                    ctx.fillStyle = '#ffeaa7';
                    ctx.fillText(this.name, this.x, this.y - nameOffset);
                    ctx.restore();
                }

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                if (this.type === 'boss') {
                    ctx.arc(this.x - 15, this.y - 10, 10, 0, Math.PI * 2);
                    ctx.arc(this.x + 15, this.y - 10, 10, 0, Math.PI * 2);
                } else {
                    ctx.arc(this.x - 6, this.y - 4, 5, 0, Math.PI * 2);
                    ctx.arc(this.x + 6, this.y - 4, 5, 0, Math.PI * 2);
                }
                ctx.fill();

                ctx.fillStyle = '#000';
                ctx.beginPath();
                if (this.type === 'boss') {
                    ctx.arc(this.x - 15, this.y - 10, 3, 0, Math.PI * 2);
                    ctx.arc(this.x + 15, this.y - 10, 3, 0, Math.PI * 2);
                } else {
                    ctx.arc(this.x - 6, this.y - 4, 2, 0, Math.PI * 2);
                    ctx.arc(this.x + 6, this.y - 4, 2, 0, Math.PI * 2);
                }
                ctx.fill();

                // HP Bar for Boss
                if (this.type === 'boss') {
                    const barOffset = this.radius + 20;
                    const barY = this.y - barOffset;
                    const hpRatio = this.maxHp ? Math.max(0, Math.min(1, this.hp / this.maxHp)) : 1;
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - 50, barY, 100, 10);
                    ctx.fillStyle = 'lime';
                    ctx.fillRect(this.x - 50, barY, 100 * hpRatio, 10);
                }
            }
        }

        /**
         * MAIN GAME LOOP
         */

        const gameData = {
            state: 'start', // start, playing, levelup, gameover
            shake: 0,
            freeze: 0,
            waveTimer: 0,
            difficulty: 1
        };

        const upgradeLevels = {};
        const upgradePool = [
            {
                id: 'keyboard_level',
                name: '机械键盘',
                desc: '键盘等级 +1（增加多重射击）',
                canApply: () => player.weapons.keyboard.level < 3,
                apply: () => { player.weapons.keyboard.level += 1; }
            },
            {
                id: 'keyboard_rate',
                name: '狂敲加速',
                desc: '键盘冷却 -15%',
                canApply: () => (upgradeLevels.keyboard_rate || 0) < 5,
                apply: () => {
                    upgradeLevels.keyboard_rate = (upgradeLevels.keyboard_rate || 0) + 1;
                    player.weapons.keyboard.cooldown = Math.max(5, Math.floor(player.weapons.keyboard.cooldown * 0.85));
                }
            },
            {
                id: 'keyboard_extra',
                name: '并行敲击',
                desc: '键盘额外子弹 +1',
                canApply: () => (upgradeLevels.keyboard_extra || 0) < 4,
                apply: () => {
                    upgradeLevels.keyboard_extra = (upgradeLevels.keyboard_extra || 0) + 1;
                    player.keyboardExtraShots += 1;
                }
            },
            {
                id: 'printer_level',
                name: '打印机风暴',
                desc: '解锁/升级打印机（纸片更多）',
                canApply: () => player.weapons.printer.level < 3,
                apply: () => { player.weapons.printer.level += 1; }
            },
            {
                id: 'printer_rate',
                name: '超频打印',
                desc: '打印机冷却 -20%',
                canApply: () => (upgradeLevels.printer_rate || 0) < 4 && player.weapons.printer.level > 0,
                apply: () => {
                    upgradeLevels.printer_rate = (upgradeLevels.printer_rate || 0) + 1;
                    player.weapons.printer.cooldown = Math.max(25, Math.floor(player.weapons.printer.cooldown * 0.8));
                }
            },
            {
                id: 'printer_extra',
                name: '加纸托盘',
                desc: '打印机纸片 +4',
                canApply: () => (upgradeLevels.printer_extra || 0) < 5 && player.weapons.printer.level > 0,
                apply: () => {
                    upgradeLevels.printer_extra = (upgradeLevels.printer_extra || 0) + 1;
                    player.printerExtraCount += 4;
                }
            },
            {
                id: 'coffee_level',
                name: '咖啡泼洒',
                desc: '解锁/升级咖啡杯（减速+持续伤害）',
                canApply: () => player.weapons.coffee.level < 3,
                apply: () => { player.weapons.coffee.level += 1; }
            },
            {
                id: 'coffee_rate',
                name: '浓缩续杯',
                desc: '咖啡冷却 -20%',
                canApply: () => (upgradeLevels.coffee_rate || 0) < 4 && player.weapons.coffee.level > 0,
                apply: () => {
                    upgradeLevels.coffee_rate = (upgradeLevels.coffee_rate || 0) + 1;
                    player.weapons.coffee.cooldown = Math.max(60, Math.floor(player.weapons.coffee.cooldown * 0.8));
                }
            },
            {
                id: 'move_speed',
                name: '加班脚力',
                desc: '移动速度 +0.6',
                canApply: () => (upgradeLevels.move_speed || 0) < 5,
                apply: () => {
                    upgradeLevels.move_speed = (upgradeLevels.move_speed || 0) + 1;
                    player.speed += 0.6;
                }
            },
            {
                id: 'max_hp',
                name: '抗压训练',
                desc: '最大活力 +15',
                canApply: () => (upgradeLevels.max_hp || 0) < 5,
                apply: () => {
                    upgradeLevels.max_hp = (upgradeLevels.max_hp || 0) + 1;
                    player.maxHp += 15;
                    player.hp = Math.min(player.maxHp, player.hp + 15);
                }
            },
            {
                id: 'magnet',
                name: '绩效磁铁',
                desc: '拾取范围 +25',
                canApply: () => (upgradeLevels.magnet || 0) < 5,
                apply: () => {
                    upgradeLevels.magnet = (upgradeLevels.magnet || 0) + 1;
                    player.magnetRange += 25;
                }
            },
            {
                id: 'regen',
                name: '摸鱼恢复',
                desc: '每秒恢复活力 +0.5',
                canApply: () => (upgradeLevels.regen || 0) < 6,
                apply: () => {
                    upgradeLevels.regen = (upgradeLevels.regen || 0) + 1;
                    player.regen += 0.5;
                }
            },
            {
                id: 'damage_up',
                name: '暴走输出',
                desc: '整体伤害 +12%',
                canApply: () => (upgradeLevels.damage_up || 0) < 8,
                apply: () => {
                    upgradeLevels.damage_up = (upgradeLevels.damage_up || 0) + 1;
                    player.damageMultiplier = +(player.damageMultiplier * 1.12).toFixed(3);
                }
            },
            {
                id: 'projectile_speed',
                name: '火速投递',
                desc: '子弹速度 +15%',
                canApply: () => (upgradeLevels.projectile_speed || 0) < 6,
                apply: () => {
                    upgradeLevels.projectile_speed = (upgradeLevels.projectile_speed || 0) + 1;
                    player.projectileSpeed = +(player.projectileSpeed * 1.15).toFixed(3);
                }
            },
            {
                id: 'projectile_size',
                name: '加大键帽',
                desc: '子弹体积 +15%',
                canApply: () => (upgradeLevels.projectile_size || 0) < 6,
                apply: () => {
                    upgradeLevels.projectile_size = (upgradeLevels.projectile_size || 0) + 1;
                    player.projectileSize = Math.min(2.2, +(player.projectileSize + 0.15).toFixed(2));
                }
            },
            {
                id: 'crit_chance',
                name: '致命绩效',
                desc: '暴击率 +5%',
                canApply: () => (upgradeLevels.crit_chance || 0) < 6,
                apply: () => {
                    upgradeLevels.crit_chance = (upgradeLevels.crit_chance || 0) + 1;
                    player.critChance = Math.min(0.35, +(player.critChance + 0.05).toFixed(3));
                }
            },
            {
                id: 'exp_gain',
                name: 'KPI加班',
                desc: '经验获取 +10%',
                canApply: () => (upgradeLevels.exp_gain || 0) < 8,
                apply: () => {
                    upgradeLevels.exp_gain = (upgradeLevels.exp_gain || 0) + 1;
                    player.expGain = +(player.expGain * 1.1).toFixed(3);
                }
            },
            {
                id: 'keyboard_pierce',
                name: '键帽穿透',
                desc: '键盘子弹穿透 +1',
                canApply: () => (upgradeLevels.keyboard_pierce || 0) < 3,
                apply: () => {
                    upgradeLevels.keyboard_pierce = (upgradeLevels.keyboard_pierce || 0) + 1;
                    player.keyboardPierce += 1;
                }
            },
            {
                id: 'chair_unlock',
                name: '旋转办公椅',
                desc: '解锁/增加旋转椅 +1',
                canApply: () => (upgradeLevels.chair_unlock || 0) < 4,
                apply: () => {
                    upgradeLevels.chair_unlock = (upgradeLevels.chair_unlock || 0) + 1;
                    player.chairCount += 1;
                }
            },
            {
                id: 'chair_speed',
                name: '椅子加速',
                desc: '旋转速度 +15%',
                canApply: () => (upgradeLevels.chair_speed || 0) < 5 && player.chairCount > 0,
                apply: () => {
                    upgradeLevels.chair_speed = (upgradeLevels.chair_speed || 0) + 1;
                    player.chairSpeed = +(player.chairSpeed * 1.15).toFixed(3);
                }
            },
            {
                id: 'chair_radius',
                name: '椅子外扩',
                desc: '旋转半径 +10',
                canApply: () => (upgradeLevels.chair_radius || 0) < 5 && player.chairCount > 0,
                apply: () => {
                    upgradeLevels.chair_radius = (upgradeLevels.chair_radius || 0) + 1;
                    player.chairRadius += 10;
                }
            },
            {
                id: 'chair_damage',
                name: '椅子重击',
                desc: '旋转椅伤害 +1',
                canApply: () => (upgradeLevels.chair_damage || 0) < 4 && player.chairCount > 0,
                apply: () => {
                    upgradeLevels.chair_damage = (upgradeLevels.chair_damage || 0) + 1;
                    player.chairDamage += 1;
                }
            },
            {
                id: 'kill_heal',
                name: '绩效回血',
                desc: '击败敌人回复活力 +2',
                canApply: () => (upgradeLevels.kill_heal || 0) < 5,
                apply: () => {
                    upgradeLevels.kill_heal = (upgradeLevels.kill_heal || 0) + 1;
                    player.killHeal += 2;
                }
            },
            {
                id: 'coffee_spread',
                name: '咖啡扩散',
                desc: '咖啡范围 +20',
                canApply: () => (upgradeLevels.coffee_spread || 0) < 4 && player.weapons.coffee.level > 0,
                apply: () => {
                    upgradeLevels.coffee_spread = (upgradeLevels.coffee_spread || 0) + 1;
                    player.coffeeRadiusBonus += 20;
                }
            },
            {
                id: 'coffee_linger',
                name: '回味持久',
                desc: '咖啡持续时间 +60',
                canApply: () => (upgradeLevels.coffee_linger || 0) < 4 && player.weapons.coffee.level > 0,
                apply: () => {
                    upgradeLevels.coffee_linger = (upgradeLevels.coffee_linger || 0) + 1;
                    player.coffeeDurationBonus += 60;
                }
            }
        ];

        let currentUpgradeOptions = [];

        function getUpgradeOptions(count) {
            const pool = upgradePool.filter(option => option.canApply());
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            return pool.slice(0, Math.min(count, pool.length));
        }

        function addExperience(amount) {
            player.exp += amount * player.expGain;
            while (player.exp >= player.expToNext) {
                player.exp -= player.expToNext;
                player.expToNext = Math.floor(player.expToNext * 1.25 + 20);
                player.pendingLevelUps++;
                player.level++;
            }
            if (player.pendingLevelUps > 0 && gameData.state === 'playing') {
                showLevelUp();
            }
        }

        function showLevelUp() {
            gameData.state = 'levelup';
            levelUpOverlay.classList.remove('hidden');
            upgradeOptions.innerHTML = '';
            currentUpgradeOptions = getUpgradeOptions(3);
            if (currentUpgradeOptions.length === 0) {
                player.hp = player.maxHp;
                player.pendingLevelUps--;
                levelUpOverlay.classList.add('hidden');
                gameData.state = 'playing';
                return;
            }
            currentUpgradeOptions.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.className = 'upgrade-card';
                btn.innerHTML = `<div class="upgrade-title">${option.name}</div><div class="upgrade-desc">${option.desc}</div>`;
                btn.addEventListener('click', () => chooseUpgrade(index));
                upgradeOptions.appendChild(btn);
            });
        }

        function chooseUpgrade(index) {
            const option = currentUpgradeOptions[index];
            if (!option) return;
            option.apply();
            levelUpOverlay.classList.add('hidden');
            player.pendingLevelUps--;
            if (player.pendingLevelUps > 0) {
                showLevelUp();
                return;
            }
            gameData.state = 'playing';
        }

        function defeatEnemy(e) {
            if (e.markedForDeletion) return;
            e.markedForDeletion = true;
            const dropExp = Math.min(900, Math.max(5, Math.round(e.score * 0.5)));
            drops.push(new Drop(e.x, e.y, dropExp));
            player.kpi += e.score;
            addExperience(e.score);
            if (player.killHeal > 0) {
                player.hp = Math.min(player.maxHp, player.hp + player.killHeal);
            }
            spawnParticles(e.x, e.y, '#fff', 15);
        }

        function damageEnemy(e, amount, angle, silent = false) {
            if (e.markedForDeletion) return;
            e.hp -= amount;
            if (angle !== null && angle !== undefined) {
                e.body.hit(angle, 5);
            }
            if (!silent) {
                spawnParticles(e.x, e.y, e.color, 5);
                AudioSys.playSound('hit');
                gameData.shake = Math.max(gameData.shake, 3);
            }
            if (e.hp <= 0) {
                defeatEnemy(e);
            }
        }

        function handleChairHits() {
            if (player.chairCount <= 0) return;
            const chairs = getChairPositions();
            if (chairs.length === 0) return;
            const hitRadius = 14;
            for (const e of enemies) {
                if (e.markedForDeletion || e.chairHitCooldown > 0) continue;
                for (const c of chairs) {
                    if (dist(c.x, c.y, e.x, e.y) < e.radius + hitRadius) {
                        const angle = Math.atan2(e.y - c.y, e.x - c.x);
                        damageEnemy(e, player.chairDamage, angle);
                        e.chairHitCooldown = 10;
                        break;
                    }
                }
            }
        }

        function checkCollisions() {
            // Projectiles vs Enemies
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.owner && p.owner !== 'player') continue;

                // Enemy Hit
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (dist(p.x, p.y, e.x, e.y) < e.radius + p.radius) {
                        // Hit!
                        let damage = p.damage || 1;
                        if (player.critChance > 0 && Math.random() < player.critChance) {
                            damage *= player.critMultiplier;
                            spawnParticles(e.x, e.y, '#f6e58d', 6);
                        }
                        damageEnemy(e, damage, Math.atan2(p.vy, p.vx));

                        if (p.pierce > 0) {
                            p.pierce--;
                        } else {
                            projectiles.splice(i, 1);
                        }
                        break;
                    }
                }
            }

            // Player vs Drops
            for (let i = drops.length - 1; i >= 0; i--) {
                const d = drops[i];
                const distToPlayer = dist(d.x, d.y, player.x, player.y);

                // Magnet
                if (distToPlayer < player.magnetRange) {
                    d.x += (player.x - d.x) * 0.1;
                    d.y += (player.y - d.y) * 0.1;
                }

                if (distToPlayer < player.body.radius + 10) {
                    drops.splice(i, 1);
                    player.kpi += 10;
                    addExperience(d.expValue || 10);
                    AudioSys.playSound('coin');
                    // Heal small amount
                    player.hp = Math.min(player.maxHp, player.hp + 2);
                }
            }

            // Enemies vs Player
            let hitPlayer = false;
            let damageTaken = 0;
            for (const e of enemies) {
                if (dist(e.x, e.y, player.x, player.y) < e.radius + player.body.radius) {
                    hitPlayer = true;
                    const contactDamage = e.contactDamage !== undefined
                        ? e.contactDamage
                        : (e.type === 'boss' ? 5 : e.type === 'manager' ? 3 : 2);
                    damageTaken = Math.max(damageTaken, contactDamage);
                    // Pushback
                    const angle = Math.atan2(player.y - e.y, player.x - e.x);
                    player.x += Math.cos(angle) * 5;
                    player.y += Math.sin(angle) * 5;
                }
            }

            // Projectiles (Enemy) vs Player
            // For boss projectiles mostly
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.owner === 'enemy') {
                    if (dist(p.x, p.y, player.x, player.y) < p.radius + player.body.radius) {
                        hitPlayer = true;
                        damageTaken = Math.max(damageTaken, p.damage || 2);
                        projectiles.splice(i, 1);
                    }
                }
            }

            if (hitPlayer) {
                player.hp -= damageTaken;
                gameData.shake = 5;
                player.body.hit(rand(0, 6), 5);
                if (player.hp <= 0) {
                    gameOver();
                }
            }
        }

        function spawnWave() {
            gameData.waveTimer++;

            if (gameData.waveTimer === 1) {
                for (let i = 0; i < 3; i++) enemies.push(new Enemy('colleague'));
                if (Math.random() > 0.3 && countEnemiesByType('manager') < 8) {
                    enemies.push(new Enemy('manager'));
                }
            }

            const spawnRate = Math.max(12, 70 - Math.floor(gameData.waveTimer / 45)); // Increases over time

            if (countEnemiesByType('boss') === 0) {
                if (gameData.waveTimer % spawnRate === 0) {
                    let type = Math.random() > 0.8 ? 'manager' : 'colleague';
                    if (type === 'manager' && countEnemiesByType('manager') >= 8) {
                        type = 'colleague';
                    }
                    enemies.push(new Enemy(type));
                }
            }

            // Boss Spawn
            if (gameData.waveTimer === 5400 || gameData.waveTimer === 14400) { // 90s, 240s
                if (countEnemiesByType('boss') < 1) {
                    enemies.push(new Enemy('boss'));
                    showBossWarning();
                }
                // Clear small enemies
                // enemies.forEach(e => { if (e.type !== 'boss') e.hp = 0; });
            }
        }

        function showBossWarning() {
            bossWarning.classList.remove('show');
            bossFlash.classList.remove('show');
            void bossWarning.offsetWidth;
            bossWarning.classList.add('show');
            bossFlash.classList.add('show');
            gameData.shake = Math.max(gameData.shake, 12);
            document.body.classList.add('alarm-shake');
            setTimeout(() => {
                bossWarning.classList.remove('show');
                bossFlash.classList.remove('show');
                document.body.classList.remove('alarm-shake');
            }, 1200);
        }

        function update() {
            if (gameData.state !== 'playing') return;

            if (gameData.freeze > 0) {
                gameData.freeze--;
                return;
            }

            player.update();
            spawnWave();

            // Updates
            projectiles.forEach((p, i) => {
                p.update();
                const outRange = dist(p.x, p.y, player.x, player.y) > Math.max(screenWidth, screenHeight) * 1.5 + 300;
                if (p.life <= 0 || outRange) {
                    projectiles.splice(i, 1);
                }
            });

            enemies.forEach(e => e.update());
            drops.forEach(d => d.update());
            for (let i = coffeeZones.length - 1; i >= 0; i--) {
                coffeeZones[i].update();
                if (coffeeZones[i].life <= 0) coffeeZones.splice(i, 1);
            }
            particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) particles.splice(i, 1);
            });

            // Cleanup dead enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (enemies[i].markedForDeletion) enemies.splice(i, 1);
            }

            for (let i = drops.length - 1; i >= 0; i--) {
                const d = drops[i];
                if (dist(d.x, d.y, player.x, player.y) > Math.max(screenWidth, screenHeight) * 2.2) {
                    drops.splice(i, 1);
                }
            }

            handleChairHits();
            checkCollisions();

            // HUD
            kpiValue.innerText = `${player.kpi}`;
            const expRatio = Math.max(0, Math.min(1, player.exp / player.expToNext));
            expFill.style.width = `${Math.floor(expRatio * 100)}%`;
            levelPill.innerText = `LV. ${player.level}`;
            expText.innerText = `${Math.floor(player.exp)}/${player.expToNext}`;
            nextExp.innerText = `还需 ${Math.max(0, player.expToNext - Math.floor(player.exp))}`;
        }

        function draw() {
            // Clear with office background color
            const bg = ctx.createLinearGradient(0, 0, 0, screenHeight);
            bg.addColorStop(0, '#f7f9fb');
            bg.addColorStop(1, '#e7ecf1');
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Subtle wall pattern
            ctx.save();
            ctx.globalAlpha = 0.06;
            ctx.strokeStyle = '#a4b0be';
            ctx.lineWidth = 1;
            for (let x = -screenHeight; x < screenWidth + screenHeight; x += 60) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + screenHeight, screenHeight);
                ctx.stroke();
            }
            ctx.restore();

            // Grid lines (Office floor tiles) - infinite loop
            const tileSize = 100;
            const offsetX = ((-camera.x) % tileSize + tileSize) % tileSize;
            const offsetY = ((-camera.y) % tileSize + tileSize) % tileSize;
            ctx.strokeStyle = '#dcdde1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = offsetX; x < screenWidth; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, screenHeight); }
            for (let y = offsetY; y < screenHeight; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(screenWidth, y); }
            ctx.stroke();

            ctx.save();

            // Screen Shake
            let shakeX = 0;
            let shakeY = 0;
            if (gameData.shake > 0) {
                shakeX = rand(-gameData.shake, gameData.shake);
                shakeY = rand(-gameData.shake, gameData.shake);
                gameData.shake *= 0.9;
                if (gameData.shake < 0.5) gameData.shake = 0;
            }

            ctx.translate(-camera.x + shakeX, -camera.y + shakeY);

            // Office decor (procedural, non-colliding)
            const decoSize = 650;
            const startX = Math.floor((camera.x - screenWidth) / decoSize);
            const endX = Math.floor((camera.x + screenWidth) / decoSize);
            const startY = Math.floor((camera.y - screenHeight) / decoSize);
            const endY = Math.floor((camera.y + screenHeight) / decoSize);
            for (let gx = startX; gx <= endX; gx++) {
                for (let gy = startY; gy <= endY; gy++) {
                    const baseX = gx * decoSize + decoSize / 2;
                    const baseY = gy * decoSize + decoSize / 2;
                    const r1 = randFromCoord(gx, gy, 1);
                    const r2 = randFromCoord(gx, gy, 2);
                    const r3 = randFromCoord(gx, gy, 3);
                    const r4 = randFromCoord(gx, gy, 4);
                    const r5 = randFromCoord(gx, gy, 5);
                    const r6 = randFromCoord(gx, gy, 6);
                    const r7 = randFromCoord(gx, gy, 7);

                    // Desks + monitors
                    if (r1 > 0.2) {
                        const dx = baseX + (r2 - 0.5) * 200;
                        const dy = baseY + (r3 - 0.5) * 200;
                        ctx.save();
                        ctx.translate(dx, dy);
                        ctx.rotate((r1 - 0.5) * 0.15);
                        ctx.fillStyle = '#f5f6fa';
                        ctx.strokeStyle = '#2f3640';
                        ctx.lineWidth = 2;
                        ctx.fillRect(-80, -32, 160, 64);
                        ctx.strokeRect(-80, -32, 160, 64);
                        ctx.fillStyle = '#dfe6e9';
                        ctx.fillRect(-50, -20, 60, 32);
                        ctx.fillStyle = '#2d3436';
                        ctx.fillRect(20, -18, 40, 26);
                        ctx.fillStyle = '#636e72';
                        ctx.fillRect(24, -14, 32, 18);
                        // Desk number
                        const deskId = Math.floor(randFromCoord(gx, gy, 11) * 90 + 10);
                        ctx.fillStyle = '#111';
                        ctx.fillRect(-78, -30, 28, 12);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`#${deskId}`, -75, -24);
                        ctx.restore();
                    }

                    // Sofa / lounge
                    if (r2 > 0.6) {
                        const sx = baseX + (randFromCoord(gx, gy, 4) - 0.5) * 240;
                        const sy = baseY + (randFromCoord(gx, gy, 5) - 0.5) * 240;
                        ctx.save();
                        ctx.translate(sx, sy);
                        ctx.fillStyle = '#74b9ff';
                        ctx.strokeStyle = '#2f3640';
                        ctx.lineWidth = 2;
                        ctx.fillRect(-60, -18, 120, 36);
                        ctx.strokeRect(-60, -18, 120, 36);
                        ctx.fillStyle = '#a4c8ff';
                        ctx.fillRect(-52, -12, 104, 12);
                        ctx.restore();
                    }

                    // Plants
                    if (r3 > 0.5) {
                        const px = baseX + (randFromCoord(gx, gy, 6) - 0.5) * 260;
                        const py = baseY + (randFromCoord(gx, gy, 7) - 0.5) * 260;
                        ctx.save();
                        ctx.translate(px, py);
                        ctx.fillStyle = '#2ecc71';
                        ctx.beginPath();
                        ctx.arc(0, -10, 18, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(-8, -14, 12, 0, Math.PI * 2);
                        ctx.arc(10, -12, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#8d6e63';
                        ctx.fillRect(-14, 8, 28, 14);
                        ctx.strokeStyle = '#2f3640';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-14, 8, 28, 14);
                        ctx.restore();
                    }

                    // OKR whiteboard
                    if (r4 > 0.72) {
                        const wx = baseX + (r5 - 0.5) * 260;
                        const wy = baseY + (r6 - 0.5) * 260;
                        ctx.save();
                        ctx.translate(wx, wy);
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = '#2f3640';
                        ctx.lineWidth = 2;
                        ctx.fillRect(-70, -40, 140, 80);
                        ctx.strokeRect(-70, -40, 140, 80);
                        ctx.fillStyle = '#ff7675';
                        ctx.fillRect(-70, -40, 140, 14);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('OKR', 0, -33);
                        ctx.fillStyle = '#2d3436';
                        ctx.fillRect(-55, -10, 110, 6);
                        ctx.fillRect(-55, 2, 90, 6);
                        ctx.fillRect(-55, 14, 70, 6);
                        ctx.restore();
                    }

                    // Blackboard wall
                    if (r5 > 0.75) {
                        const bx = baseX + (r6 - 0.5) * 260;
                        const by = baseY + (r7 - 0.5) * 260;
                        ctx.save();
                        ctx.translate(bx, by);
                        ctx.fillStyle = '#1b4332';
                        ctx.strokeStyle = '#0b2a1c';
                        ctx.lineWidth = 3;
                        ctx.fillRect(-80, -45, 160, 90);
                        ctx.strokeRect(-80, -45, 160, 90);
                        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-60, -20);
                        ctx.lineTo(50, -20);
                        ctx.moveTo(-60, 0);
                        ctx.lineTo(30, 0);
                        ctx.moveTo(-60, 20);
                        ctx.lineTo(10, 20);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Coffee bar
                    if (r6 > 0.78) {
                        const cx = baseX + (r7 - 0.5) * 260;
                        const cy = baseY + (r1 - 0.5) * 260;
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.fillStyle = '#dcdde1';
                        ctx.strokeStyle = '#2f3640';
                        ctx.lineWidth = 2;
                        ctx.fillRect(-90, -18, 180, 36);
                        ctx.strokeRect(-90, -18, 180, 36);
                        ctx.fillStyle = '#353b48';
                        ctx.fillRect(-70, -30, 50, 24);
                        ctx.fillStyle = '#718093';
                        ctx.fillRect(-60, -26, 30, 14);
                        ctx.fillStyle = '#fbc531';
                        ctx.beginPath();
                        ctx.arc(40, -6, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#e1b12c';
                        ctx.fillRect(32, 2, 16, 6);
                        ctx.restore();
                    }

                    // Glass panels / posters
                    if (r1 < 0.35) {
                        const wx = baseX + (randFromCoord(gx, gy, 8) - 0.5) * 260;
                        const wy = baseY + (randFromCoord(gx, gy, 9) - 0.5) * 260;
                        ctx.save();
                        ctx.translate(wx, wy);
                        ctx.fillStyle = 'rgba(116, 185, 255, 0.18)';
                        ctx.strokeStyle = '#2f3640';
                        ctx.lineWidth = 2;
                        ctx.fillRect(-60, -40, 120, 80);
                        ctx.strokeRect(-60, -40, 120, 80);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-40, -10, 80, 10);
                        ctx.fillRect(-40, 6, 60, 6);
                        ctx.restore();
                    }
                }
            }

            // Draw Shadows
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for (const e of enemies) {
                ctx.beginPath(); ctx.ellipse(e.x, e.y + e.radius, e.radius, e.radius * 0.3, 0, 0, Math.PI * 2); ctx.fill();
            }
            ctx.beginPath(); ctx.ellipse(player.x, player.y + 25, 25, 8, 0, 0, Math.PI * 2); ctx.fill();

            // Draw Objects
            drops.forEach(d => d.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            coffeeZones.forEach(z => z.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            drawChairs(ctx);
            if (player.body) player.draw(ctx);
            particles.forEach(p => p.draw(ctx));

            ctx.restore();
        }

        function loop() {
            requestAnimationFrame(loop);
            update();
            draw();
        }

        // Game Flow Control
        const startOverlay = document.getElementById('start-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const levelUpOverlay = document.getElementById('level-up-overlay');
        const pauseOverlay = document.getElementById('pause-overlay');
        const upgradeOptions = document.getElementById('upgrade-options');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const bossWarning = document.getElementById('boss-warning');
        const bossFlash = document.getElementById('boss-flash');
        const kpiValue = document.getElementById('kpi-value');
        const expFill = document.getElementById('exp-fill');
        const expText = document.getElementById('exp-text');
        const levelPill = document.getElementById('level-pill');
        const nextExp = document.getElementById('next-exp');

        function startGame() {
            AudioSys.init();
            startOverlay.classList.add('hidden');
            gameOverOverlay.classList.add('hidden');
            levelUpOverlay.classList.add('hidden');
            pauseOverlay.classList.add('hidden');
            gameData.state = 'playing';
            gameData.waveTimer = 0;
            gameData.shake = 0;
            gameData.freeze = 0;
            projectiles.length = 0;
            enemies.length = 0;
            drops.length = 0;
            particles.length = 0;
            coffeeZones.length = 0;
            for (const key in upgradeLevels) delete upgradeLevels[key];
            player.init();
            updateCamera();
        }

        function gameOver() {
            gameData.state = 'gameover';
            document.getElementById('final-score').innerText = `KPI 达成率: ${player.kpi}`;
            levelUpOverlay.classList.add('hidden');
            pauseOverlay.classList.add('hidden');
            gameOverOverlay.classList.remove('hidden');
        }

        function togglePause() {
            if (gameData.state === 'playing') {
                gameData.state = 'paused';
                pauseOverlay.classList.remove('hidden');
            } else if (gameData.state === 'paused') {
                gameData.state = 'playing';
                pauseOverlay.classList.add('hidden');
            }
        }

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);
        resumeBtn.addEventListener('click', togglePause);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (gameData.state === 'playing' || gameData.state === 'paused') {
                    e.preventDefault();
                    togglePause();
                }
                return;
            }
            if (gameData.state !== 'levelup') return;
            const index = parseInt(e.key, 10) - 1;
            if (index >= 0 && index < 3) {
                chooseUpgrade(index);
            }
        });

        // Init Loop
        loop();

    </script>
</body>

</html>
